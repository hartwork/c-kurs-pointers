% Copyright (C) 2009 Sebastian Pipping <sebastian@pipping.org>
% Licensed under Creative Commons Attribution-ShareAlike 3.0 License
%
\newcommand{\ind}{\hspace*{3ex}}
\setbeamertemplate{footline}{\vspace*{-2cm}\hfill\Large\insertpagenumber\vspace*{0.5ex}\hspace*{0.5ex}}
\newcommand{\highlight}[1]{{\color{yellow} #1}}
\newcommand{\exclamation}{!}
\newcommand{\comment}[1]{}
\newcommand{\introslide}[1]{
    {\setbeamertemplate{footline}{}
        \begin{frame}%<beamer>
            \frametitle{}
            \begin{center}\Huge
                #1
            \end{center}
        \end{frame}
    }
}
\AtBeginSection[] % Do nothing for \section*
{
    \introslide{\insertsection}
}
\AtBeginSubsection[] % Do nothing for \subsection*
{
    \introslide{\insertsubsection}
}


==== C-Kurs ====
{\Large
\begin{tabular}{ll@{~~~}l}
~        & Mi  & Konzepte, Syntax, ... \\
~        & ~   & printf, scanf \\[1ex]
Next --> & Do  & Pointer, Arrays, ... \\
~        & ~   & Compiler, Headers, ... \\[1ex]
~        & Fr  & Structs, malloc, ... \\
~        & ~   & Debugging I, ... \\
~        & ~   & + Vorstellung der Aufgabe \\[3ex]
~        & Mo  & Lösung der Aufgabe \\[1ex]
~        & Di  & Debugging II \\
~        & ~   & stdlib, Bücher, ... \\
\end{tabular}
}

==== ====
{\Huge
<[center]
Ohne Pointer geht nichts.
[center]>
}


==== Themen ====
{\large
* Hello pointer
* Call by Reference
* \texttt{NULL}-Pointer
* Pointer auf Pointer
* Von Pointern zu Arrays
* Pointer-Arithmetik
* Strings und Längenberechnung
* Const Correctness
* Initialisierung von Strings
* \texttt{argc} und \texttt{argv}
* Mehrdimensionale Arrays\vspace*{1ex}
* Weiterführende Themen
* Zusammenfassung
}
%* Strings versus "Memory"


== Pointer ==


==== Variablen im RAM ====
<[center]
\vspace*{-5ex}%
\only<1>{
<<<graphics/ram-minus-3,height=0.95\textheight>>>
}\only<2>{
<<<graphics/ram-minus-2,height=0.95\textheight>>>
}\only<3>{
<<<graphics/ram-minus-1,height=0.95\textheight>>>
}\only<4>{
<<<graphics/ram-minus-0,height=0.95\textheight>>>
}
[center]>


==== ====
{\LARGE
\glqq{}Pointer\grqq{} kann meinen eine...\\[1ex]
\begin{itemize}
\item[A)]$\,$\uncover<2->{Adresse}\\
\item[B)]$\,$\uncover<3->{Variable, die eine Adresse speichert}
\end{itemize}
}


== Hello pointer ==

==== Hello pointer ====
{\ttfamily\large
    \#include <stdio.h>\\
~\\
    int main() \{\\
    \uncover<2->{~~int i = 3;\\}
    \uncover<3->{~~int * p = \&i;\\}
~\\
    \uncover<6->{~~printf(``i == \%d, p == \%p$\backslash$n'', i, p);\\}
    \uncover<4->{~~*p = 0;\\}
    \uncover<6->{~~printf(``i == \%d, p == \%p$\backslash$n'', i, p);\\}
    \uncover<5->{~~p = 0;\\}
    \uncover<6->{~~printf(``i == \%d, p == \%p$\backslash$n'', i, p);\\}
~\\
    ~~return 0;\\
    \}
}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,hello\_pointer.c~\,-o hello\_pointer\\
    \uncover<2->{\# ./hello\_pointer\\
    \uncover<3->{i == 3, p == 0xbfa3ad8c\\
    \uncover<4->{i == 0, p == 0xbfa3ad8c\\
    \uncover<5->{i == 0, p == (nil)\\}}}}
}


==== Zusammenfassung 1/2 ====
{\LARGE
*$\,$\uncover<1->{Operator \texttt{\&} liefert eine Adresse}
*$\,$\uncover<2->{Operator \texttt{*} folgt einer Adresse\\\ind{}(er \emph{dereferenziert})}
*$\,$\uncover<3->{\texttt{\&} und \texttt{*} sind komplementär; es gilt:\\\ind{}\texttt{*(\&x) = x}}
}


==== Zusammenfassung 2/2 ====
{\LARGE
<[center]
Pointer zeigen auf typisierte Daten:\\[1ex]
\texttt{int *}~~$\neq$~~\texttt{char *}
[center]>
}


== Call by Reference ==

==== Call by Reference ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
\uncover<4->{void by\_value~~~~(int~~~j) \{~~~j += 3;~~\}\\
void by\_reference(int * p)~\{~~*p += 4;~~\}}\\
~\\
int main() \{\\
~~int i = 0;\\
~\\
~~\uncover<2->{by\_value(i);\\}
~~\uncover<5->{printf(``i == \%d$\backslash$n'', i);\\}
~~\uncover<3->{by\_reference(\&i);\\}
~~\uncover<5->{printf(``i == \%d$\backslash$n'', i);\\}
~\\
~~return 0;\\
\}
}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,call\_by\_reference.c $\backslash$\\
    ~~~~~~-o call\_by\_reference\\
    \uncover<2->{\# ./call\_by\_reference\\
    \uncover<3->{i == 0\\
    i == 4}}
}


== \texttt{NULL}-Pointer ==

==== \texttt{NULL}-Pointer ====
{\ttfamily\Large
    \#include <stdlib.h>~~/* for NULL */\\
    ...\\
    int * p = NULL;\\
    \uncover<2->{...\\
    int b = *p;\uncover<3->{\textsf{~\highlight{ <-- BANG!}}}\\}
}


== Pointer auf Pointer ==

==== Pointer auf Pointer ====
{\ttfamily\Huge
    int i = 3;\\
    int * p = \&i;\\[1ex]
    \uncover<2->{int ** pp = \&p;}
}

==== Anwendungen ====
{\LARGE
* $\,$Mehrdimensionale Arrays
* $\,$\uncover<2->{Call by Reference \emph{von} Pointern}
}


==== Anwendungen ====
{\ttfamily\large
STRTOD(3)\hfill{}Linux Programmer's Manual\hfill{}STRTOD(3)\\
~\\
NAME\\
\ind{}strtod, strtof, strtold - convert ASCII string\\\hfill{}to floating-point number\\
~\\
SYNOPSIS\\
\ind{}\#include <stdlib.h>\\
~\\
\ind{}double strtod(const char *nptr, \only<1>{char **endptr}\only<2>{\highlight{char **endptr}});\\
\ind{}float strtof(const char *nptr, \only<1>{char **endptr}\only<2>{\highlight{char **endptr}});\\
~\\
\ldots{}
}


== Von Pointern zu Arrays ==

==== Von Pointern zu Arrays ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
\uncover<2->{void dump(const int * data, int count) \{\\
~~\uncover<3->{int i = 0;\\
~~for (; i < count; ++i) \{\\
~~~~\uncover<4->{printf(``Field \%d: \%d$\backslash$n'', i + 1, \only<4>{\highlight{*(data + i)}}\only<5>{\highlight{data[i]}}\only<6->{data[i]});}\\
~~\}}\\
\}}\\
~\\
int main() \{\\
~~\uncover<6->{int const primes[] = \{2, 3, 5, 7, 11\};\\
~~\uncover<7->{dump(primes, \only<7>{5}\only<8->{\highlight{sizeof(primes) / sizeof(int)}});}}\\
~~return 0;\\
\}
}

==== Zusammenfassung~~(1/5) ====
{\LARGE
<[center]
Array-Zugriff via \texttt{[\emph{n}]} ähnlich Java
[center]>
}

==== Zusammenfassung~~(2/5) ====
{\LARGE
<[center]
Array~\,=\,~Pointer auf das erste Element
[center]>
}

==== Zusammenfassung~~(3/5) ====
{\ttfamily\Huge
<[center]
\emph{a}[\emph{n}]~\,\textsf{=}\,~*(\emph{a} + \emph{n})
[center]>
}

==== Zusammenfassung~~(4/5) ====
{\Large
<[center]
\texttt{sizeof(\emph{variable})}\\=\\
Von \texttt{\emph{variable}} belegter Speicher in Byte
[center]>
}

==== Zusammenfassung~~(5/5) ====
{\Large
<[center]
\texttt{sizeof(\highlight{\emph{type}})}\\=\\
Von \highlight{\texttt{\emph{type}}-Instanzen} belegter Speicher in Byte
[center]>
}



== Pointer-Arithmetik ==

==== Pointer-Arithmetik ====
{\Large
    {\ttfamily
        int numbers[3];\\
        char text[] = ``software libre'';\\
    }
~\\
    \uncover<2->{Es gilt:\\
    {\ttfamily
        \ind{}1.~numbers[i]~\,\textsf{=}\,~*(numbers + i)\\
        \ind{}2.~\uncover<3->{text[j]~\,\textsf{=}\,~*(text + j)\\}
        \ind{}3.~\uncover<4->{sizeof(char)~\,$\neq$\,~sizeof(int)\\}
    }
~\\
    \uncover<5->{Für Operatoren +/- auf Pointern folgt:\\}
    \uncover<6->{\ind{}Sprungweite variiert mit dem Typen!\\}}
}


== Strings ==

==== Strings ====
{\ttfamily\LARGE
    ``ABC''\uncover<2->{~\,\textsf{=}\,~\{\;65, 66, 67, 0\;\}\\
    \uncover<3->{``012''\uncover<4->{~\,\textsf{=}\,~\{\;48, 49, 50, 0\;\}\\}}
    \uncover<5->{``012$\backslash$0''\uncover<6->{~\,\textsf{=}\,~\{\;48, 49, 50, 0, 0\;\}\\}}
~\\[1ex]
    \uncover<7->{{\ttfamily
        \#include <string.h>\\
        ...\\
        strlen(``ABC'');\\[1ex]
    }
    \uncover<8->{\textsf{=}\,~3\\}}}
}

==== my\_strlen ====
{\ttfamily\LARGE
    int my\_strlen(const char * str) \{\\
    \uncover<2->{~~char const * const begin = str;\\}
    \uncover<3->{~~while (*str) \{\\
    ~~~~str++;\\
    ~~\}\\}
    ~~return (\uncover<4->{\highlight{str - begin}});\\
    \}
}


== Const Correctness ==

==== Const Correctness~~(1/6) ====
{\LARGE
<[center]
Modifikator \texttt{const}\\verbietet Schreibzugriff
[center]>
}

==== Const Correctness~~(2/6) ====
{\ttfamily\LARGE
~~\only<1,3->{\underline{~~~~~}}\only<2>{\underline{\highlight{const}}} int \only<-2>{\underline{~~~~~}}\only<3->{\underline{\highlight{const}}} foo;\\~\\\phantom{<2a>}
}

==== Const Correctness~~(3/6) ====
{\ttfamily\LARGE
~~\underline{~~~~~}~int~\underline{~~~~~}~*~\underline{~~~~~}~foo;\\
~~\uncover<3->{~~|~~~~~~~~~|~~~~~}\uncover<2->{~~|\\}
~~\uncover<3->{~<2a>~~~~~~<2b>~~~}\uncover<2->{~<1>\\}
}

==== Const Correctness~~(4/6) ====
{\ttfamily\LARGE
    <1>~~\underline{~~~~~}~int~\underline{~~~~~}~*~\underline{const}~foo;\\
    \uncover<2->{~~~~~~~\textsf{Verboten:}\\
    ~~~~~~~foo = \ldots{};\\
~\\
    \uncover<3->{<2a>~\underline{const}~int~\underline{~~~~~}~*~\underline{~~~~~}~foo;\\
    <2b>~\underline{~~~~~}~int~\underline{const}~*~\underline{~~~~~}~foo;\\
    \uncover<4->{~~~~~~~\textsf{Verboten:}\\
    ~~~~~~~foo[0] = \ldots{};\\}}}
}

==== Const Correctness~~(5/6) ====
{\ttfamily\LARGE
    <2a,1>~\underline{const}~int~\underline{~~~~~}~*~\underline{const}~foo;\\
    <2b,1>~\underline{~~~~~}~int~\underline{const}~*~\underline{const}~foo;\\
    \uncover<2->{~~~~~~~\textsf{Verboten:}\\
    ~~~~~~~~~~foo~= \ldots{};\\
    ~~~~~~~foo[0]~= \ldots{};}
}

==== Const Correctness~~(6/6) ====
{\ttfamily\LARGE
    ~~~~const int * const * foo;\\
    \uncover<2->{~~~~~~~\textsf{Erlaubt:}\\
    ~~~~~~~~~~~~~foo~= \ldots{};\\}
    \uncover<3->{~~~~~~~\textsf{Verboten:}\\
    ~~~~~~~~~~foo[0]~= \ldots{};\\
    ~~~~~~~foo[0][0]~= \ldots{};\\}
}


==== Const Correctness in APIs ====
{\Large
    \texttt{int my\_strlen(\phantom{const}~char * str);\\}
    \uncover<2->{\ind{}Funktion darf \emph{Inhalt} von \texttt{str} verändern\\}
    \uncover<3->{\ind{}\texttt{my\_strlen(``ABC'')} gibt Compile-Fehler\\}
~\\
    \texttt{int my\_strlen(\underline{const}~char * str);\\}
    \uncover<4->{\ind{}Funktion darf Inhalt von \texttt{str} \emph{nicht} verändern\\}
    \uncover<5->{\ind{}\texttt{my\_strlen(``ABC'')} erlaubt und sicher\\}
}


== Initialisierung von Strings ==

==== Initialisierung von Strings ====
{\Large
    \uncover<3->{Variante \glqq{}Mit Array\grqq{}\\}
    \ind{}\texttt{char a[] = ``Hallo'';}\\
    \uncover<2->{\ind{}\texttt{sizeof(a) = sizeof(char)*(5 + 1)}\\}
    \uncover<4->{\ind{}Inhalt les- und schreibbar\\}
~\\
    \uncover<5->{Variante \glqq{}Nur Pointer\grqq{}\\}
    \uncover<6->{\ind{}\texttt{\only<9->{\highlight{const} }char * p = ``Hallo'';}\\}  % gcc -Wwrite-strings
    \uncover<7->{\ind{}\texttt{sizeof(p) = sizeof(char *)}\\}
    \uncover<8->{\ind{}Inhalt \emph{nicht} schreibbar\\}
}

==== Variante \glqq{}Nur Pointer\grqq{} ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
int main() \{\\
~~char * a = ``hallo'';\\
~~char * b = ``hallo'';\\
~\\
~~\uncover<2->{printf(``a=\%p$\backslash$n''\\
~~~~~~~~~``b=\%p$\backslash$n'', a, b);\\
~\\
~~\uncover<3->{a[0] = `X';\\}}
~\\
~~return 0;\\
\}
}

==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,rombad.c~\,-o rombad\\
    \uncover<2->{\# ./rombad\\
    \uncover<3->{a=\only<3,5->{0x80484dc}\only<4>{0x\highlight{80484dc}}\\
    b=\only<3,5->{0x80484dc}\only<4>{0x\highlight{80484dc}}\\
    \uncover<5->{Segmentation fault}}}
}

==== GCC Flag \texttt{-Wwrite-strings} ====
{\ttfamily\large
    \# gcc~\,-Wall -Wextra \highlight{-Wwrite-strings} $\backslash$\\
    ~~~~~~rombad.c~\,-o rombad\\
    \uncover<2->{rombad.c: In function `main':\\
    rombad.c:4: warning: initialization discards\\
    ~~~~qualifiers from pointer target type\\
    rombad.c:5: warning: initialization discards\\
    ~~~~qualifiers from pointer target type}
}

==== Variante \glqq{}Nur Pointer\grqq{} ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
int main() \{\\
~~\only<2>{\highlight{const~}}\only<3->{const~}char * a = ``hallo'';\\
~~\only<2>{\highlight{const~}}\only<3->{const~}char * b = ``hallo'';\\
~\\
~~printf(``a=\%p$\backslash$n''\\
~~~~~~~~~``b=\%p$\backslash$n'', a, b);\\
~\\
~~\only<3>{\highlight{a[0] = `X';}}\only<-2>{a[0] = `X';}\\
~\\
~~return 0;\\
\}
}


== \texttt{argc} und \texttt{argv} ==

==== \texttt{argc} und \texttt{argv} ====
{\ttfamily\Large
    \#include <stdio.h>\\
~\\
    int main(\only<2->{int argc, char ** argv}) \{\\
    \uncover<4->{~~int i = 0;\\}
    \uncover<3->{~~printf(``\%d parameters$\backslash$n'', argc - 1);\\}
    \uncover<4->{~~for (; i < argc; ++i) \{\\
    \uncover<5->{~~~~printf(``[\%d] \%s$\backslash$n'', i, argv[i]);\\}
    ~~\}\\}
    ~~return 0;\\
    \}
}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,print\_args.c~\,-o print\_args\\
    \uncover<2->{\# ./print\_args~free 'open source' software\\}
    \uncover<3->{3 parameters\\
    {}[0] ./print\_args\\
    {}[1] free\\
    {}[2] open source\\
    {}[3] software\\}
}


== Mehrdimensionale Arrays ==
{
\subsection*{Variante \glqq{}Array von Pointern\grqq{}}
\introslide{Variante\\\glqq{}Array von Pointern\grqq{}}
}

==== 2D-Array als Array von Pointern ====
<[center]
\only<1>{
<<<graphics/array-deep-minus-4,height=0.7\textheight>>>
}\only<2>{
<<<graphics/array-deep-minus-3,height=0.7\textheight>>>
}\only<3>{
<<<graphics/array-deep-minus-2,height=0.7\textheight>>>
}\only<4>{
<<<graphics/array-deep-minus-1,height=0.7\textheight>>>
}\only<5>{
<<<graphics/array-deep-minus-0,height=0.7\textheight>>>
}
[center]>

==== 2D-Array als Array von Pointern ====
{\ttfamily\Large
    \uncover<4->{void demo\_deep(\highlight{int *} const \highlight{* a}) \{\\
    ~~a[1][2] *= 2;\\
    \}\\}
~\\
    int main() \{\\
    \uncover<2->{~~int row0[] = \{0, 1, 2\};\\
    ~~int row1[] = \{3, 4, 5\};\\
    ~~int * const d[] = \{row0, row1\};\\
    \uncover<3->{~~demo\_deep(d);\\}}
    ~~return 0;\\
    \}\\
}

=== Variante \glqq{}Linear\grqq{} ===

==== 2D-Array linear ====
<[center]
\only<1>{
<<<graphics/array-flat-minus-3,height=0.7\textheight>>>
}\only<2>{
<<<graphics/array-flat-minus-2,height=0.7\textheight>>>
}\only<3>{
<<<graphics/array-flat-minus-1,height=0.7\textheight>>>
}\only<4>{
<<<graphics/array-flat-minus-0,height=0.7\textheight>>>
}
[center]>

==== 2D-Array linear ====
{\ttfamily\Large
    \uncover<4->{void demo\_flat(\highlight{int a[][3]}) \{\\
    ~~a[1][2] *= 2;\\
    \}\\}
~\\
    int main() \{\\
    \uncover<2->{~~int f[][3] = \{ \{0, 1, 2\},\\
    ~~~~~~~~~~~~~~~~~\{3, 4, 5\} \};\\
    \uncover<3->{~~demo\_flat(f);\\}}
    ~~return 0;\\
    \}
}

=== Variante \glqq{}Hybrid\grqq{} ===

==== 2D-Array-Hybrid ====
{\ttfamily\Large
    \uncover<5->{void demo\_flat(\highlight{int a[][3]});\\
    void demo\_deep(\highlight{int *} const \highlight{* a});\\}
~\\
    int main() \{\\
    \uncover<2->{~~int f[][3] = \{ \{0, 1, 2\},\\
    ~~~~~~~~~~~~~~~~~\{3, 4, 5\} \};\\
    \uncover<3->{~~int * const d[] = \{f[0], f[1]\};\\
    \uncover<4->{~~demo\_flat(f);\\
    ~~demo\_deep(d);\\}}}
    ~~return 0;\\
    \}
}

%==== Strings versus "Memory" ====
\comment{\Large
    \underline{str}ncpy(\underline{char} *dest, const \underline{char} *src, size\_t n);\\[1.5ex]
    \underline{mem}cpy(\underline{void} *dest, const \underline{void} *src, size\_t n);\\[0.5ex]
    \uncover<2->{ohne Null-Byte-Behandlung}
}


== Weiterführende Themen ==

==== Weiterführende Themen ====
{\Large
* Character encodings, Unicode, wchar\_t
* Sicherer Umgang mit Strings
* Der Typ \texttt{size\_t}
* Void-Pointer
* Funktions-Pointer
}


== Zusammenfassung ==

==== Zusammenfassung ====
{\Large
* \texttt{sizeof(\emph{x})} liefert die Größe von \texttt{\emph{x}} in Byte
* Operator \texttt{\&} liefert eine Adresse
* Operator \texttt{*} folgt einer Adresse\\\hfill{}(er \emph{dereferenziert})
* Pointer sind typisiert
* Arrays sind Pointer auf ihr erstes Element
* Strings sind nulltermininiert
* Const Correctness bei Pointern ist wichtig
}


==== ====
<[center]
{\Huge
Danke!\\
~\\
Fragen?\\
\vfill
\vfill
}
{\LARGE http://blog.hartwork.org/}
[center]>
\vspace*{-4ex}