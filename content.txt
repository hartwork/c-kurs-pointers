% Copyright (C) 2009 Sebastian Pipping <sebastian@pipping.org>
% Licensed under Creative Commons Attribution-ShareAlike 3.0 License
%
\newcommand{\ind}{\hspace*{3ex}}
\mode<beamer>{
	\newcommand{\highlight}[1]{{\color{yellow} #1}}
	\newcommand{\underlinehighlight}[1]{\underline{\highlight{#1}}}
}
\mode<handout>{
	\newcommand{\highlight}[1]{\underline{#1}}
	\newcommand{\underlinehighlight}[1]{\highlight{#1}}
}

\newcommand{\exclamation}{!}
\newcommand{\comment}[1]{}
\newcommand{\introslide}[1]{
    {\setbeamertemplate{footline}{}
        \begin{frame}%<beamer>
            \frametitle{}
            \begin{center}\Huge
                #1
            \end{center}
        \end{frame}
    }
}

\newcommand{\enableintroslides}[0]{
	\AtBeginSection[] % Do nothing for \section*
	{
		\introslide{\insertsection}
	}
	\AtBeginSubsection[] % Do nothing for \subsection*
	{
		\introslide{\insertsubsection}
	}
}

\newcommand{\disableintroslides}[0]{
	\AtBeginSection[] % Do nothing for \section*
	{}
	\AtBeginSubsection[] % Do nothing for \subsection*
	{}
}


\newlength{\parskipbackup}
\setlength{\parskipbackup}{\parskip}
\newlength{\parindentbackup}
\setlength{\parindentbackup}{\parindent}

\let\notebackup\note
\renewcommand{\note}[1]{\notebackup{%
	\setlength{\parindent}{0ex}%
	\setlength{\parskip}{10pt}%
	\noindent%
	{\normalsize{}#1}%
	\setlength{\parskip}{\parskipbackup}%
	\setlength{\parindent}{\parindentbackup}%
}%
}


==== ====
	\titlepage
	\vfill
	\begin{center}
		\CcGroupBySa{0.33}{0.95ex}\\[2.5ex]
		{\tiny\CcNote{\CcLongnameBySa}}
		\vspace*{13ex}
	\end{center}
	\vspace*{-5ex}
	\vspace*{-0.5\textheight}\hspace*{0.65\textwidth}\cwfslogo{}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Willkommen zum dritten Tag des C-Kurses.

	Mein Name ist Sebastian Pipping.  Das dritte Jahr spreche
	ich nun im Rahmen des C-Kurses über Arrays, Strings und Pointer.

	Viel von dem, was ich die nächste Stunde vermitteln will,
	haben Sie gestern bereits gesehen, teilweise auch angewandt.
	Die nächsten 60 Minuten werde ich sowohl Inhalte wiederholen
	als auch tiefer einsteigen.

	Ganz wichtig zur Vorlesung:
	Bitte unterbrechen Sie mich, wenn Verständnisfragen auftauchen.
	Das fördert die Lebendigkeit dieser Vorlesung und trägt dazu bei,
	dass alle am Ball bleiben, auch wenn es mal etwas theoretischer wird.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>


\enableintroslides{}
\setbeamertemplate{footline}{\vspace*{-2cm}\hfill\Large\insertpagenumber\vspace*{0.5ex}\hspace*{0.5ex}}


\disableintroslides{}
\section{Einführung}
\enableintroslides{}

==== ====
{\Huge
<[center]
Ohne Pointer geht nichts.
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Ich möchte beginnen mit dem Statement:
	\glqq{}Ohne Pointer geht nichts\grqq{}, wenigstens
	nicht in C.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== ====
{\LARGE
Pointer sind Grundlage für:
* Arrays
* Strings
* Call by Reference
* Komplexe Datentypen
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Pointer sind die Grundlage für Arrays, Strings,
	Call by Reference und komplexe Datentypen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>


\disableintroslides{}
\section{Themen}
\enableintroslides{}

\newcommand{\tocslide}[1]{%

==== Themen ====
{\large
* Hello Pointer
* Call by Reference
* Pointer auf Pointer
* Vom Pointer zum Array
* Pointer-Arithmetik
* Strings, Längencodierung, String API
* Const Correctness
* Initialisierung von Strings
* Mehrdimensionale Arrays
* Programm-Argumente: \texttt{argc} und \texttt{argv}\vspace*{1ex}
* Weiterführende Themen
* Zusammenfassung
}
{#1}
[frame]>
}

\tocslide{%
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Und weil in C nichts ohne Pointer geht, werde ich neben
	Arrays und Strings auch Pointer selbst in Detail beleuchten.

	In \glqq{}Hello Pointer\grqq{} möchte ich Pointer an einem Minimalbeispiel
	vorstellen:
		Was ist das Konzept?
		Wie lautet die Syntax?
		Wie ist der Bezug zum Arbeitsspeicher?

	Danach möchte unter Verwendung von Pointern Call by Reference
	nachbauen, also Funktionen erlauben, ausgewählten Variablen der
	Welt um sie herum zu verändern.

	Gelegentlich zeigen Pointer auch auf andere Pointer.
	Dazu werde ich ein Beispiel aus der realen Welt vorstellen.

	In \glqq{}Vom Pointer zum Array\grqq{} werden wir die Funktionsweise von
	Arrays näher kennenlernen.

	Damit sind wir direkt beim Thema \glqq{}Pointer-Arithmetik\grqq{} und
	was sich hinter diesem Begriff verbirgt.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
}

\mode<handout>{
\tocslide{%
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Aufbauend auf unserem Wissen über Arrays werde ich dann
	Strings als spezielle Arrays vorstellen, wie deren Länge
	codiert wird und welche Konsequenzen das hat.

	Bevor ich die zwei verschiedenen Arten der Initialisierung von
	Strings vorstellen kann, muss ich in \glqq{}Const Correctness\grqq{}
	ein paar Grundlagen aufbauen: An ein paar Stellen ist die
	Frage \glqq{}konstant oder nicht konstant\grqq{} \emph{keine}
	Geschmacksache.

	Auch für die Repräsentation von mehrdimensionalen Arrays
	gibt es in C zwei Varianten.  Ihnen Hilfe für diese Stolperfalle
	mit auf den Weg zu geben, ist mir wichtig.

	Mit dem bis dahin aufgebauten Verständnis sind wir dann
	in der Lage, die Argumente des Programmaufrufs auszulesen,
	was ich mit passendem Code demonstrieren werde.

	Danach möchte ich mit einer Zusammenfassung und einem Ausblick
	schließen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
}
}


\disableintroslides{}
\section{Definition Pointer}
\enableintroslides{}


==== ====
{\Huge
<[center]
Was ist ein \glqq{}Pointer\grqq{}?
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Also was ist ein \glqq{}Pointer\grqq{}?
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== ====
{\LARGE
\glqq{}Pointer\grqq{} kann meinen eine \ldots{}\\[1ex]
\begin{itemize}
\item[A)]$\,$\uncover<2->{Adresse}\\
\item[B)]$\,$\uncover<3->{Variable, die eine Adresse speichert}
\end{itemize}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	\glqq{}Pointer\grqq{} meint entweder eine Adresse --- einen Wert ---
	oder eine Variable,
	die eine Adresse speichert.  Diese Mehrdeutigkeit ist gar nichts
	wirklich Neues: Das Wort \glqq{}Integer\grqq{} verwenden wir ganz
	selbstverständlich zum einen für ganze Zahlen --- sagen wir die 3 ---
	und zum anderen für Variablen die ganze Zahlen speichern:
	wir sagen \glqq{}$i$ ist ein Integer\grqq{}.

	\glqq{}Pointer\grqq{} meint also eine Adresse oder eine Variable,
	die eine Adresse speichert.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Hello Pointer ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Hello Pointer - lassen Sie uns dazu etwas Code ansehen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Beispielcode}
\enableintroslides{}


==== Hello Pointer ====
{\ttfamily\large
    \#include <stdio.h>\\
~\\
    int main() \{\\
    \uncover<2->{~~int i = 3;\\}
    \uncover<3->{~~int * p = \&i;\\}
~\\
    \uncover<6->{~~printf(``i == \%d, p == \%p$\backslash$n'', i, p);\\}
    \uncover<4->{~~*p = 4;\\}
    \uncover<6->{~~printf(``i == \%d, p == \%p$\backslash$n'', i, p);\\}
    \uncover<5->{~~p = 5;\\}
    \uncover<6->{~~printf(``i == \%d, p == \%p$\backslash$n'', i, p);\\}
~\\
    ~~return 0;\\
    \}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Beginnen wir mit einem Gerüst, dass Ihnen inzwischen
	sehr bekannt vorkommen sollte.

	Wir definieren einen Integer $i$ --- bisher nichts Neues.

	Als Nächstes definieren wir einen Pointer $p$, der auf $i$ zeigt.
	Der \&-Operator liefert hierbei die Adresse --- den Speicherort ---
	von $i$.  $p$ ist vom Typ \glqq{}int Stern\grqq{}:
	ein Pointer auf einen \texttt{int}.

	Danach schreiben wir den Wert 4 nach \texttt{*p}.  Der *-Operator folgt
	der Adresse in $p$ - wir schreiben also effektiv in den Speicher
	von $i$!

	$p$ selbst ist auch schreibbar --- hier schreiben wir den Wert 5.

	Als Letztes fügen wir noch ein paar \text{printf()}s ein,
	um die Werte von $i$ und $p$ auszugeben.

	Lassen Sie uns das einmal ausführen \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Ausgabe}
\enableintroslides{}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,hello\_pointer.c~\,-o hello\_pointer\\
    \uncover<2->{\# ./hello\_pointer\\}
    \uncover<3->{i == 3, p == 0xbfa3ad8c\\}
    \uncover<4->{~~~~~~~~~~~~~~~~~~~~~~~~~|~*p = 4;\\}
    \uncover<5->{i == 4, p == 0xbfa3ad8c\\}
    \uncover<6->{~~~~~~~~~~~~~~~~~~~~~~~~~|~p = 5;\\}
    \uncover<7->{i == 4, p == 0x5\\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Erstmal kompilieren wir das.

	Dann ausführen \ldots{}

	Integer $i$ ist 3 --- so wie wir es initialisiert hatten --- und Pointer $p$
	zeigt auf $i$, das an Adresse \glqq{}bfa und so weiter\grqq{} liegt.
	Nebenbei: Diese Adresse kann bei jeden Aufruf verschieden sein.

	Zur Erinnerung: Dann kam \texttt{*p = 4;}.

	Weil der *-Operator der Adresse in $p$ folgt, landet die 4 in $i$.
	Der Pointer $p$ selbst bleibt unverändert.

	Dann kam \texttt{p = 5;}.

	Diesmal wird $p$ selbst verändert: $p$ zeigt jetzt auf Adresse 5.

	Lassen Sie mich das kurz zusammenfassen \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Zusammenfassung}
\enableintroslides{}


==== Zusammenfassung 1/2 ====
{\LARGE
*$\,$\uncover<1->{Operator \texttt{\&} liefert eine Adresse}
*$\,$\uncover<2->{Operator \texttt{*} folgt einer Adresse\\\ind{}(er \emph{dereferenziert})}
*$\,$\uncover<3->{\texttt{\&} und \texttt{*} sind komplementär; es gilt:\\\ind{}\texttt{*(\&x) = x = \&(*x)}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Operator \& liefert eine Adresse.

	Operator * folgt einer Adresse.  Man sagt auch \glqq{}er dereferenziert\grqq{}.

	Besonders für die Mathematiker unter Ihnen:
	Diese beiden Operatoren sind komplementär.
	Wenn ich nach der Adresse von $x$ frage und dann dieser Adresse
	folge arbeite ich wieder mit $x$ selbst --- und anders herum.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Zusammenfassung 2/2 ====
{\LARGE
<[center]
Pointer zeigen auf typisierte Daten:\\[1ex]
\texttt{int *}~~$\neq$~~\texttt{char *}
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Pointer zeigen auf typisierte Daten.
	Es gibt einen Unterschied zwischen Pointern auf \texttt{int}s
	und Pointern auch \texttt{char}s.  Diese Unterscheidung ist die
	Grundlage für Pointer-Arithmetik --- dazu später mehr.

	Zuvor möchte ich Ihnen zeigen, wie man mithilfe von Pointern
	Call by Reference in C nachbaut.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Call by Reference ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Zur Erinnerung: Call by Reference bedeutet, einer Funktion
	zu erlauben, ausgewählten Variablen der Welt um sie herum
	zu verändern.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Beispielcode}
\enableintroslides{}


==== Call by Reference ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
\uncover<4->{void by\_value~~~~(int~~~x) \{~~~x += 3;~~\}\\
void by\_reference(int * x)~\{~~*x += 4;~~\}}\\
~\\
int main() \{\\
~~int i = 0;\\
~\\
~~\uncover<2->{by\_value(i);\\}
~~\uncover<5->{printf(``i == \%d$\backslash$n'', i);\\}
~~\uncover<3->{by\_reference(\&i);\\}
~~\uncover<5->{printf(``i == \%d$\backslash$n'', i);\\}
~\\
~~return 0;\\
\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Fangen wir an mit einem bekannten Gerüst: mit einer
	\texttt{main}-Funktion und einem Integer $i$.

	Übergeben wir $i$ nun an eine Funktion \texttt{by\_value} und
	eine Funktion \texttt{by\_reference}.

	\texttt{by\_value} verändert Paramater $x$, arbeitet somit auf
	einem kopierten Wert von $i$.

	\texttt{by\_reference} dagegen schreibt in den Speicher hinter
	der kopierten Adresse von \texttt{\&i} und verändert
	damit den Wert von $i$.

	Welchen Wert hat $i$ also am Ende von \texttt{main()}?

	<PAUSE>

	Fügen wir noch ein paar \texttt{printf()}s ein und lassen es laufen \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Ausgabe}
\enableintroslides{}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,call\_by\_reference.c $\backslash$\\
    ~~~~~~-o call\_by\_reference\\
    \uncover<2->{\# ./call\_by\_reference\\
    \uncover<3->{i == 0\\
    i == 4}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kompilieren, ausführen, $i$ ist 0 und dann 4.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Pointer auf Pointer ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Auch Pointer auf Pointer, manchmal \glqq{}Doppelpointer\grqq{}
	oder \glqq{}Pointer-Pointer\grqq{} genannt,
	werden regelmäßig gebraucht.

	Zum Beispiel für \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Anwendungen}
\enableintroslides{}


==== Anwendungen ====
{\LARGE
* $\,$Mehrdimensionale Arrays
* $\,$\uncover<2->{Call by Reference \emph{von} Pointern}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	\ldots{} mehrdimensionale Arrays oder wenn Pointer selbst
	mittels Call by Reference verändert werden sollen.

	Eine Funktion, die Sie selbst verwenden werden, macht
	Gebrauch davon: \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{man strtod}
\enableintroslides{}


==== man strtod ====
{\ttfamily\large
STRTOD(3)\hfill{}Linux Programmer's Manual\hfill{}STRTOD(3)\\
~\\
NAME\\
\ind{}strtod, strtof, strtold - convert ASCII string\\\hfill{}to floating-point number\\
~\\
SYNOPSIS\\
\ind{}\#include <stdlib.h>\\
~\\
\ind{}double strtod(const char *nptr, \alt<2>{\highlight{char **endptr}}{char **endptr});\\
\ind{}float strtof(const char *nptr, \alt<2>{\highlight{char **endptr}}{char **endptr});\\
~\\
\ldots{}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	\ldots{} die Funktion \texttt{strtod()}.

	Hier sehen Sie einen Ausschnitt aus der Manpage von
	\texttt{strtod()}.

	Unten rechts sehen Sie einen Pointer auf einen Pointer.
	\texttt{strtod()} arbeitet mit Call by Reference.
	In einer unserer Übungsaufgaben können Sie genau
	mit dieser Funktion herumexperimentieren.

	Wirklich schwer sind Doppelpointer nicht; außer einem weiteren
	Stern erwartet Sie auch syntaktisch nichts Neues.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Beispielcode}
\enableintroslides{}


==== Pointer auf Pointer ====
{\ttfamily\Huge
    int i = 3;\\
    int * p = \&i;\\[1ex]
    \uncover<2->{int ** pp = \&p;}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Das kennen Sie schon: Pointer $p$ wird mit der Adresse von $i$
	initialisiert.

	$p$ ist ein einfacher Pointer.

	Hier wird nun Doppelpointer $pp$ mit der Adresse von $p$
	initialisiert: Wir setzen also eine weitere Indirektionsschicht
	oben drauf.

	Vielleicht sollten wir uns das auch mal im RAM ansehen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Variablen im RAM ====
<[center]
\vspace*{-3ex}%
\mode<beamer>{
<<<graphics/ram-minus-0,height=0.94\textheight>>>
}
\mode<handout>{
<<<graphics/ram-minus-0-black,height=0.94\textheight>>>
}
[center]>
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Gibt es Fragen bis hierher?
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Vom Pointer zum Array ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	In C hängen Arrays und Pointer zusammen.

	Schauen wir uns an, wie dieser Zusammenhang genau aussieht.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Beispielcode}
\enableintroslides{}


==== Vom Pointer zum Array ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
\uncover<2->{void dump(const int * data, int count) \{\\
~~\uncover<3->{int i = 0;\\
~~for (; i < count; i++) \{\\
~~~~\uncover<4->{printf(``Field \%d: \%d$\backslash$n'', i + 1, \alt<4>{\highlight{*(data + i)}}{\alt<5>{\highlight{data[i]}}{data[i]}});}\\
~~\}}\\
\}}\\
~\\
int main() \{\\
~~\\
~~\\
~~return 0;\\
\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Dieses Gerüst kennen Sie schon.

	Hier definiere ich eine Funktion \texttt{dump}, die Daten ausgeben soll.
	Die Daten sind Integer, die im Speicher direkt
	hintereinanderliegen: ein Array von \texttt{int}s.

	Von diesen \texttt{int}s gibt es \texttt{count} viele, der erste von ihnen
	liegt an Adresse \texttt{data}.

	Was ich jetzt machen kann, ist, mit einer simplen \texttt{for}-Schleife
	über die Daten iterieren und jedes Datum einzeln ausgeben.

	An den jeweiligen Wert gelangen wir, indem wir zu der
	Basisadresse \texttt{data} den Index $i$ addieren und dann der
	resultierenden Adresse folgen.

	Sind Sie einverstanden, dass das so funktioniert?
	
	<PAUSE>
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

==== Vom Pointer zum Array ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
void dump(const int * data, int count) \{\\
~~int i = 0;\\
~~for (; i < count; i++) \{\\
~~~~printf(``Field \%d: \%d$\backslash$n'', i + 1, \alt<1>{\highlight{data[i]}}{data[i]});\\
~~\}\\
\}\\
~\\
int main() \{\\
~~\uncover<2->{int const primes[] = \{2, 3, 5, 7, 11\};\\
~~\uncover<3->{dump(primes, \alt<0| handout:1>{\highlight{5}}{5});}}\\
~~return 0;\\
\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Wenn Sie jetzt denken, dass diese Syntax unnötig hässlich ist:
	Sie haben Recht: Dafür gibt es eine Kurzschreibweise.
	Diese Syntax kennen Sie vermutlich bereits von Java.

	Lassen Sie uns nun die Funktion mit Daten füttern.

	Hier definieren wir ein Array, das die 5 kleinsten Primzahlen
	enthält und rufen \texttt{dump()} damit auf.

	Die Länge des Arrays müssen wir explizit übergeben, weil
	die Funktion \texttt{dump()} einem Pointer allein nicht ansehen kann,
	wie lang das Array dahinter ist: die Länge von Arrays
	muss mitherumgeschleppt werden!
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

==== Vom Pointer zum Array ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
void dump(const int * data, int count) \{\\
~~int i = 0;\\
~~for (; i < count; i++) \{\\
~~~~printf(``Field \%d: \%d$\backslash$n'', i + 1, \alt<0| handout:1>{\highlight{data[i]}}{data[i]});\\
~~\}\\
\}\\
~\\
int main() \{\\
~~int const primes[] = \{2, 3, 5, 7, 11\only<2>{, \highlight{13, 17}}\};\\
~~dump(primes, \alt<1>{\highlight{sizeof(primes) / sizeof(int)}}{sizeof(primes) / sizeof(int)});\\
~~return 0;\\
\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Dass wir explizit sagen müssen, dass unser Array 5 Einträge
	lang ist, ist unflexibel und fehleranfällig.

	Vermeiden lässt sich das hier mithilfe des \texttt{sizeof}-Operators.
	\texttt{sizeof} erkennt zur Compilezeit, wieviele Byte Speicher sein
	Argument belegt.  Auf einer 32-Bit-Machine belegt das Array
	\texttt{primes} 20 Byte, ein \texttt{int} belegt 4 Byte.
	20 geteilt durch 4 sind 5.

	Durch diesen Trick könnten wir nun zwei weitere Primzahlen an
	\texttt{primes} anhängen, ohne den Aufruf von \texttt{dump()}
	anpassen zu müssen.

	Lassen Sie mich das eben zusammenfassen \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Zusammenfassung}
\enableintroslides{}


==== Zusammenfassung~~(1/5) ====
{\LARGE
<[center]
Array-Zugriff via \texttt{[\emph{k}]} ähnlich Java
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Der Array-Zugriff funktioniert mit eckigen Klammern und einem
	Index $k$ wie auch in Java.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Zusammenfassung~~(2/5) ====
{\LARGE
<[center]
Array~\,=\,~Pointer auf das erste Element
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Ein Array ist auch ein Pointer auf sein erstes Element.
	Mit dieser Adresse können wir auch direkt arbeiten,
	konkret: damit rechnen.  Mehr dazu später.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Zusammenfassung~~(3/5) ====
{\ttfamily\Huge
<[center]
\emph{a}[\emph{k}]~\,\textsf{=}\,~*(\emph{a} + \emph{k})
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Die Syntax mit den eckigen Klammern ist eine syntaktische
	Abkürzung.  Eigentlich wird die Adresse des ersten Elements
	gelesen, der Index $k$ addiert und dann der resultierenden
	Adresse gefolgt.

	Array-Zugriff ist also auch dereferenzieren!
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Zusammenfassung~~(4/5) ====
{\Large
<[center]
\texttt{sizeof(\emph{variable})}\\=\\
Von \texttt{\emph{variable}} belegter Speicher in Byte
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Der Operator \texttt{sizeof} liefert die Anzahl Byte, die eine
	Variable im Speicher belegen wird.

	Diese Auswertung geschieht zur Compilezeit.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Zusammenfassung~~(5/5) ====
{\Large
<[center]
\mode<beamer>{\texttt{sizeof(\highlight{\emph{type}})}\\=\\
Von \highlight{\texttt{\emph{type}}-Instanzen} belegter Speicher in Byte}
\mode<handout>{\texttt{sizeof(\emph{type})}\\=\\
Von \texttt{\emph{type}}-Instanzen belegter Speicher in Byte}
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Des Weiteren kann \texttt{sizeof} auch die Größe von Typen bestimmen:
	wieviele Byte Speicher wird Typ \texttt{xy} belegen.

	\texttt{sizeof} kann noch ein bisschen mehr, aber weitere Details
	sind im Augenblick nicht wichtig.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Pointer-Arithmetik ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kommen wir nun zu Pointer-Arithmetik, die wir vorhin
	bereits mehrfach verwendet haben.

	Mit Pointern kann man Rechnen, daher Arithmetik.

	Beim Array-Zugriff passiert das automatisch.
	Aber was passiert da eigentlich genau?
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Pointer-Arithmetik ====
{\Large
    {\ttfamily
        int numbers[3];\\
        char text[] = ``software libre'';\\
    }
~\\
    \uncover<2->{Es gilt:\\
    {\ttfamily
        \ind{}1.~numbers[i]~\,\textsf{=}\,~*(numbers + i)\\
        \ind{}2.~\uncover<3->{text[j]~\,\textsf{=}\,~*(text + j)\\}
        \ind{}3.~\uncover<4->{sizeof(char)~\,$\neq$\,~sizeof(int)\\}
    }
~\\
    \uncover<5->{Für Operatoren +/- auf Pointern folgt daher:\\}
    \uncover<6->{\ind{}Sprungweite variiert mit dem Typen!\\}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Angenommen wir haben zwei Arrays: \texttt{numbers} und \texttt{text}.
	Eins von denen ist ein String, aber das stört nicht weiter.

	Ein paar Dinge müssen dann gelten:
	%
	\vspace*{-2ex}%
	\begin{enumerate}%
	\item
		Der Array-Zugriff auf Array \texttt{numbers} gehorcht dieser Formel;
		das hatte ich ja vorhin eingeführt.
	\item
		Auch der Array-Zugriff auf Array \texttt{text} gehorcht dieser
		Formel.
	\item
		\texttt{char} und \texttt{int} sind meist nicht gleich groß.
	\end{enumerate}%
	\vspace*{-1ex}%
	%
	Gibt es da nicht ein Problem - kann das funktionieren?
	Ich geb die Frage mal an Sie weiter: kann das funktionieren?~~<PAUSE>

	Für die Operatoren Plus und Minus auf Pointern folgt:
	Die Sprungweite variiert mit dem Typen.
	Auf einer 32-Bit-Machine springt \texttt{numbers + 1}
	vier Byte wegen $\texttt{sizeof(int)} = 4$, aber \texttt{text + 1} springt
	nur ein Byte weiter wegen $\texttt{sizeof(char)} = 1$.
	Das ist der Grund, warum \texttt{int *} und \texttt{char *} nicht das
	Gleiche sind.  Der Compiler braucht diese Information für Pointer-Arithmetik.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Strings ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kommen wir nun zu ganz speziellen Arrays, zu Strings.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Längencodierung}
\enableintroslides{}


==== Längencodierung ====
{\Large
Pascal Strings\\
\ind{}{\ttfamily``ABC''~\sexyarrowrightLarge{}~\{\;\highlight{3}, 65, 66, 67\;\}}\\
~\\
\uncover<2->{C Strings\\[0.55ex]%workaround
\ind{}{\ttfamily``ABC''~\sexyarrowrightLarge{}~\{\;65, 66, 67, \highlight{0}\;\}}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Strings sind in C spezielle Arrays.
	Das besondere an ihnen ist, dass Sie Ihre Länge verraten.

	In der programmiersprache Pascal sieht der String \glqq{}ABC\grqq{}
	so aus: 4 Byte, ein Byte für die Länge --- 3 --- gefolgt von
	den ASCII-Werten für die Großbuchstaben \glqq{}A\grqq{}, \glqq{}B\grqq{} und \glqq{}C\grqq{}.

	In C wird das anders gelöst.  Aus \glqq{}ABC\grqq{} macht der Compiler
	die ASCII-Werte von \glqq{}A\grqq{}, \glqq{}B\grqq{} und \glqq{}C\grqq{}
	gefolgt von 0, genannt Nullterminator.

	Frage an Sie: Was fallen Ihnen für diese Varianten an
	Vor- und Nachteilen ein?~~<PAUSE>
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Strings ====
{\ttfamily\LARGE
    ``ABC''\phantom{$\backslash$0}\uncover<2->{~\sexyarrowrightLARGE{}~\{\;65, 66, 67, 0\;\}\\
    \uncover<3->{``012''\phantom{$\backslash$0}\uncover<4->{~\sexyarrowrightLARGE{}~\{\;48, 49, 50, 0\;\}\\}}
    \uncover<5->{``012$\backslash$0''\uncover<6->{~\sexyarrowrightLARGE{}~\{\;48, 49, 50, 0, 0\;\}\\}}
~\\[1ex]
    \uncover<7->{{\ttfamily
        \#include <string.h>\\
        ...\\
        strlen(``ABC$\backslash$0$\backslash$0'');\\[1ex]
    }
    \uncover<8->{\textsf{=}\,~3\\}}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Aus \glqq{}ABC\grqq{} wird also das Array: 65, 66, 67, 0.

	Dass die Null das Ende des Strings markiert heißt aber nicht,
	dass wir die Zahl Null nicht in einen String schreiben dürfen:

	Dieser String - \glqq{}012\grqq{} - wird ersetzt durch 48, 49, 50, 0.
	Der ASCII-Wert des Zeichens \glqq{}0\grqq{} ist 48.

	Künstlich den ASCII-Wert Null einfügen können wir auch:
	Aus 0, 1, 2, Backslash 0 wird 48, 49, 50, 0 und nochmal 0.

	Die Länge eines Strings müssen wir nicht per Hand berechnen.
	Das macht die Funktion \glqq{}strlen\grqq{} aus \texttt{string.h} für uns.

	\texttt{strlen} von \glqq{}ABC$\backslash$0$\backslash$0\grqq{} liefert den Wert 3.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{\texttt{my\_strlen}}
\enableintroslides{}


==== my\_strlen ====
{\ttfamily\LARGE
    int my\_strlen(const char * str) \{\\
    \uncover<2->{~~char const * const begin = str;\\}
    \uncover<3->{~~while (*str) \{\\
    ~~~~str++;\\
    ~~\}\\}
    ~~return (\uncover<4->{\highlight{str - begin}});\\
    \}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Ich möchte nun mit Ihnen ein eigenes \texttt{strlen()} programmieren.

	Ich habe unsere Funktion \texttt{my\_strlen} genannt.
	Sie arbeitet auf einem \texttt{char}-Pointer \glqq{}str\grqq{}.
	Zu dem \texttt{const} kommen wir später.

	Zunächst merken wir uns den Wert von str in einer eigenen
	Variable \texttt{begin}.  Wir werden str verändern --- quasi mit
	\texttt{str} über den String laufen --- und würden den ursprünglichen
	Wert sonst verlieren.

	Nun laufen wir in einer Schleife solange im String
	vorwärts, wie das aktuelle Zeichen nicht 0 ist, also
	nicht das Ende des Strings markiert.

	Nach dieser Schleife zeigt \texttt{str} genau auf den Terminator.
	Was müssen wir nun zurückgeben um die Länge des Strings zu
	erhalten?

	<PAUSE>

	Richtig: \texttt{str - begin}.  Auch das ist wieder Pointer-Arithmetik.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== String API ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Die String-API möchte ich nur kurz anreißen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Auszug}
\enableintroslides{}


==== String API (Auszug) ====
{\Large
Vergleich\\
\uncover<2->{\ind{}\texttt{strcmp}, \texttt{strncmp}, \texttt{strcasecmp}\\}
Suche\\
\uncover<2->{\ind{}\texttt{strstr}, \texttt{strchr}\\}
Formatierung, Verkettung\\
\uncover<2->{\ind{}\texttt{snprintf}\\}
Auswertung, Analyse\\
\uncover<2->{\ind{}\texttt{strtol}, \texttt{sscanf}\\}
Clonen\\
\uncover<2->{\ind{}\texttt{strdup}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Für die elementaren Operationen auf Strings sind
	Funktionen in der C-Standard-Library vorhanden:
	Vergleich, Suche, Formatierung, Clonen und mehr.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>


\disableintroslides{}
\subsection{Manpages}
\enableintroslides{}

==== Manpages ====
{\Huge\ttfamily
\# \highlight{man string}\\
\# man string.h\\
\# man stdio.h\\
\# man stdlib.h\\
~
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Die Liste der verfügbaren Funktionen und deren
	Anwengung ist in den Manpages \texttt{string}, \texttt{string.h},
	\texttt{stdio.h} und \texttt{stdlib.h} beschrieben.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


\disableintroslides{}
\subsection{Problemkandidaten}
\enableintroslides{}

==== Bitte vermeiden: ====
{\Huge
* \texttt{atoi}, \texttt{atol}, \texttt{atoll}, \texttt{atoq}
* \texttt{gets}
* \texttt{scanf}, \texttt{fscanf}, \ldots{} mit \texttt{\%s}
* \texttt{sprintf}, \texttt{vsprintf}
* \texttt{strcat}
* \texttt{strcpy}, \texttt{strncpy}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Ein paar Problemkandidaten möchte ich gerne mit Beispiel
	vorstellen.  Was ihr hier seht, sind Funktionen,
	die Sie eigentlich \emph{gar nicht} verwenden solltet.
	Mehr dazu gleich.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== ====
{\LARGE
* \texttt{gets}
* \texttt{scanf}, \texttt{fscanf}, \texttt{sscanf}, \ldots{} mit \texttt{\%s}
* \texttt{sprintf}, \texttt{vsprintf}
* \texttt{strcat}
* \texttt{strcpy}
~\\[1ex]
Buffer-Overflows\\[1ex]
Besser:\quad{}\texttt{s\underline{n}printf}, \texttt{vs\underline{n}printf}, \texttt{\underline{f}gets}\\
~
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Beginnen wir mit dieser Gruppe von Funktionen.
	Buffer-Overflows sind mit ihnen schwer bis gar nicht
	vermeidbar.

	Sehen wir uns dazu ein Beispiel an.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Beispiel \texttt{scanf} mit \texttt{\%s} ====
{\Large{\ttfamily
\#include <stdio.h>\\
~\\
void main() \{\\
\ind{}char text[3];\\
\ind{}scanf(``\%s'', text);\uncover<4->{~~~/* \highlight{Richtig: \%3s} */}\\
\}\\
~\\}
\uncover<2->{Buffer-Overflow für\\
\ind{}$\texttt{strlen(\emph{input})} \,\ge\, 3$\\
~\\
{\ttfamily
\uncover<3->{\# echo 123456789012345678901234 | ./crash\\
Segmentation fault}
}}}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Sehen wir uns \texttt{scanf} mit \texttt{\%s} an.
	\texttt{scanf} liest hier Benutzereingaben und schreibt
	einen String in das \texttt{char}-Array \texttt{text}.

	Sieht jemand ein Problem?~~<PAUSE>

	Richtig: Dieser String kann länger sein, als das Array Platz hat;
	ab einer Länge von drei schreibt \texttt{scanf} über das Ende
	des Arrays hinaus.  Auf meiner Maschine bringen 24 Zeichen
	das Programm zum Absturz.

	Sicher ist hier nur, \texttt{\%3s} zu verwenden.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Beispiel \texttt{sprintf} ====
{\Large{\ttfamily
void log\_error(const char * error) \{\\
\ind{}char text[256];\\
\ind{}sprintf(text, ``ERROR: \%s'', error);\\
\ind{}log\_message(text);\\
\}}\\
\uncover<2->{~\\
Buffer-Overflow für\\
\ind{}$\texttt{strlen(error)} \,>\, 256 - 7 - 1 = 248$\\
~\\
\uncover<3->{(Halbherzige) Abhilfe:\\
\ind{}\texttt{s\underlinehighlight{n}printf(text, \highlight{sizeof(text)}, .....);}\\
~
}}}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Ein ähnliches Problem hat die \texttt{sprintf}-Familie.

	Wie lang muss \texttt{error} sein, damit dieser Code knallt?~~<PAUSE>

	Richtig: 249 zeichen oder mehr.

	Mit s\underline{n}printf wäre das nicht passert.
	Eigentlich muss hier aber dynamisch ausreichend Speicher
	angefordert werden.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== ====
{\LARGE
* \texttt{strncpy}
~\\[12ex]
Nullterminator nicht garantiert\\[1ex]
Besser:\quad{}\texttt{snprintf}\\
~
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Diese Funktion ist auf ihre ganz eigene Art problematisch.
	Besser gleich \texttt{snprintf} verwenden.

	Sehen wir uns ein Beispiel an.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Beispiel \texttt{strncpy} ====
{\Large{\ttfamily
char text[5];\\
~\\
strncpy(text, ``Test'', sizeof(text));}\\
\uncover<2->{\ind{}\sexyarrowrightLarge~\,schreibt~\,\{\;84, 101, 115, 116, \highlight{0}\;\}\\
~\\
\uncover<3->{\texttt{strncpy(text, ``Hallo'', sizeof(text));}\\
\uncover<4->{\ind{}\sexyarrowrightLarge~\,schreibt~\,\{\;72, 97, 108, 108, \highlight{111}\;\}\\
\ind{}\sexyarrowrightLarge~\,nicht nullterminiert\\
~\\
\uncover<5->{\texttt{s\underline{n}printf(text, sizeof(text), ``\%s'',\\
\hfill{}``Hallo'');}\\
\uncover<6->{\ind{}\sexyarrowrightLarge~\,schreibt~\,\{\;72, 97, 108, 108, \highlight{0}\;\}\\
~
}}}}}}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Hier bitten wir \texttt{strncpy}, bis zu 5 Zeichen zu kopieren.
	Weil \glqq{}Test\grqq{} nur vier Zeichen lang ist, läuft das glatt:
	\texttt{strncpy} kopiert 4 Zeichen und den Nullterminator.

	Wieder bitten wir um das Kopieren von bis zu 5 Zeichen,
	bieten aber mehr Text an: \glqq{}hallo\grqq{} hat 5 Zeichen.
	\texttt{strncpy} schreibt 5 Zeichen, aber keinen Nullterminator.

	Anders mit \texttt{snprintf}: Nur 4 Zeichen werden kopiert ---
	das fünfte Zeichen ist der Nullterminator.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== ====
{\LARGE
* \texttt{atoi}
* \texttt{atol}
* \texttt{atoll}
* \texttt{atoq}
~\\[3.8ex]
Fehlerbehandlung fehlt\\[1ex]
Besser:\quad{}\texttt{strtol}, \texttt{strtoll}\\
~
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kommen wir zu etwas Lustigerem.

	Bei atoi und seinen Verwandten fehlt jegliche Fehlerbehandlung.
	Warum ist mir schleierhaft.

	Sehen wir uns das näher an.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Beispiel \texttt{atoi} ====
{\LARGE
\texttt{atoi(``Hallo'')}\phantom{\texttt{0}}\sexyarrowrightLARGE~\,0\\[1ex]
\texttt{atoi(``0'')}\phantom{\texttt{Hallo}}\sexyarrowrightLARGE~\,0\\
\uncover<2->{~\\
Problem:\\
\ind{}$\texttt{atoi(\emph{s})} = 0$~~\sexyarrowrightLARGE~\,$\texttt{\emph{s}} =\,?$\\
~\\
\uncover<3->{Idee:\\[1ex]
\ind{}Vorher $s$ mit ``0'' vergleichen?
}}}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Sowohl aus \glqq{}hallo\grqq{} als auch aus \glqq{}0\grqq{} macht
	\texttt{atoi} 0.  Wir wissen also nur, dass die Konvertierung
	erfolgreich war, wenn das Ergebnis \emph{nicht} 0 ist.

	Wenn die Rückgabe 0 ist, wissen wir nichts.

	Lässt sich dieses Problem umgehen?

	<PAUSE>
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Beispiel \texttt{atoi} ====
{\LARGE
\begin{tabular}{lcr}
	\texttt{atoi(``2'')}      & \sexyarrowrightLARGE{} & 2 \\
	\texttt{atoi(``0002'')}   & \sexyarrowrightLARGE{} & 2 \\
	\texttt{atoi(``+2'')}     & \sexyarrowrightLARGE{} & 2 \\
	\texttt{atoi(``~~2'')}    & \sexyarrowrightLARGE{} & 2 \\
	\texttt{atoi(``2Hallo'')} & \sexyarrowrightLARGE{} & 2 \\
\end{tabular}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Nicht wirklich.  Was für 2 gilt, gilt auch für 0.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Ausweg \texttt{strtol} ====
{\Large\ttfamily
\#include <stdlib.h>\\
\#include <string.h>\\
~\\
int str\_to\_long(const char * text,\\
\ind{}\ind{}long * output) \{\\
\ind{}char * end;\\
\ind{}long number = \highlight{strtol}(text, \&end, 10);\\
\ind{}if ((end != text) \&\& (*end == `$\backslash$0')) \{\\
\ind{}\ind{}*output = number;\\
\ind{}\ind{}return 1;\\
\ind{}\}\\
\ind{}return 0;\\
\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Die Lösung ist, \texttt{strtol} zu verwenden.

	Stop.  Für diesen Code braucht man etwas Ruhe und die Manpage
	von \texttt{strtol}.  Hier in der Vorlesung würde ich gern
	mit anderem Stoff weitermachen.  Die Folien sind online zu finden.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Const Correctness ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kommen wir nun zu Const Correctness, zu korrekter
	Verwendung des Modifikators \texttt{const}.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Einführung}
\enableintroslides{}


==== Const Correctness~~(1/6) ====
{\LARGE
<[center]
Modifikator \texttt{const}\\verbietet Schreibzugriff
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Zu allererst sollte ich erwähnen was \texttt{const} eigentlich
	tut: \texttt{const} verbietet Schreibzugriff auf bestimmte Variablen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Const Correctness~~(2/6) ====
{\ttfamily\LARGE
~~\temporal<2>{\underline{~~~~~}}{\underlinehighlight{const}}{\underline{~~~~~}} int \alt<3>{\underlinehighlight{const}}{\underline{~~~~~}} foo;\\~\\\phantom{<2a>}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Bei dieser Deklaration des Integers \texttt{foo} wäre const
	an zwei Stellen erlaubt: links vom \texttt{int} und rechts vom \texttt{int}.

	Auf welcher Seite man es schreibt, ist hier Geschmacksache.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Const Correctness~~(3/6) ====
{\ttfamily\LARGE
~~\underline{~~~~~}~int~\underline{~~~~~}~*~\underline{~~~~~}~foo;\\
~~\uncover<3->{~~|~~~~~~~~~|~~~~~}\uncover<2->{~~|\\}
~~\uncover<3->{~<2a>~~~~~~<2b>~~~}\uncover<2->{~<1>\\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Bei einfachen Pointern kommt nun eine weitere Stelle hinzu,
	an der \texttt{const} stehen darf.

	Ich benenne diese Stellen mal eben mit \glqq{}1\grqq{}, \glqq{}2a\grqq{} und \glqq{}2b\grqq{}.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Const Correctness~~(4/6) ====
{\ttfamily\LARGE
    <1>~~\underline{~~~~~}~int~\underline{~~~~~}~*~\underline{const}~foo;\\
    \uncover<2->{~~~~~~~\textsf{Verboten:}\\
    ~~~~~~~foo = \ldots{};\\
~\\
    \uncover<3->{<2a>~\underline{const}~int~\underline{~~~~~}~*~\underline{~~~~~}~foo;\\
    <2b>~\underline{~~~~~}~int~\underline{const}~*~\underline{~~~~~}~foo;\\
    \uncover<4->{~~~~~~~\textsf{Verboten:}\\
    ~~~~~~~foo[0] = \ldots{};\\}}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Steht const an Position 1 --- also ganz rechts bei \texttt{foo} ---
	darf der Wert von \texttt{foo} selbst nicht mehr verändert werden.

	Steht const hingegen beim \texttt{int} so darf der Inhalt hinter \texttt{foo}
	nicht geschrieben werden.

	Diese beiden Fälle lassen sich auch kombinieren \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Const Correctness~~(5/6) ====
{\ttfamily\LARGE
    <2a,1>~\underline{const}~int~\underline{~~~~~}~*~\underline{const}~foo;\\
    <2b,1>~\underline{~~~~~}~int~\underline{const}~*~\underline{const}~foo;\\
    \uncover<2->{~~~~~~~\textsf{Verboten:}\\
    ~~~~~~~~~~foo~= \ldots{};\\
    ~~~~~~~foo[0]~= \ldots{};}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Steht beim int und bei \texttt{foo} \texttt{const}, so darf weder \texttt{foo} selbst
	noch der Inhalt hinter \texttt{foo} verändert werden.

	Schauen wir uns noch ein Beispiel mit Doppelpointern an \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Const Correctness~~(6/6) ====
{\ttfamily\LARGE
    ~~~~const int * const * foo;\\
    \uncover<2->{~~~~~~~\textsf{Erlaubt:}\\
    ~~~~~~~~~~~~~foo~= \ldots{};\\}
    \uncover<3->{~~~~~~~\textsf{Verboten:}\\
    ~~~~~~~~~~foo[0]~= \ldots{};\\
    ~~~~~~~foo[0][0]~= \ldots{};\\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Was darf ich mit dieser Variable machen?

	<PAUSE>

	Richtig, ich darf \texttt{foo} selbst verändern.

	Was ich nicht verändern darf, ist der Inhalt hinter \texttt{foo} und
	der Inhalt hinter dem Inhalt von \texttt{foo}.

	Gibt es Fragen dazu?

	<PAUSE>

	Ich schulde Ihnen noch eine Erklärung zu Funktion
	\texttt{my\_strlen} von vorhin \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Fall \texttt{my\_strlen}}
\enableintroslides{}


==== Const Correctness in APIs ====
{\Large
    \texttt{int my\_strlen(\phantom{const}~char * str);\\}
    \uncover<2->{\ind{}Funktion darf \emph{Inhalt} von \texttt{str} verändern\\}
    \uncover<3->{\ind{}\texttt{my\_strlen(``ABC'')} gibt Compile-Fehler\\}
~\\
    \texttt{int my\_strlen(\underline{const}~char * str);\\}
    \uncover<4->{\ind{}Funktion darf Inhalt von \texttt{str} \emph{nicht} verändern\\}
    \uncover<5->{\ind{}\texttt{my\_strlen(``ABC'')} erlaubt und sicher\\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Hier sehen Sie zwei verschiedene Prototypen von \texttt{my\_strlen}:
	einen mit \texttt{const} und einen ohne.  Wo liegt der Unterschied?

	Aus Sicht des Compilers darf die Variante ohne \texttt{const} den
	Inhalt von \texttt{str} verändern.  Wenn wir diese Funktion mit der
	String-Konstante \glqq{}ABC\grqq{} aufrufen, wirft der Compiler einen Fehler.

	Der Typ von String-Konstanten ist \texttt{const char *}.
	Diese Variante von \texttt{my\_strlen} erwartet zuviel vom übergebenen String:
	sie erwartet, schreiben zu dürfen.

	Bei der Variante mit \texttt{const} \emph{darf} die Funktion den Inhalt von
	\texttt{str} nicht ändern.  Ein Aufruf mit der String-Konstante \glqq{}ABC\grqq{}
	ist daher erlaubt und sicher.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Initialisierung von Strings ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kommen wir nun zur Initialisierung von Strings.

	In C ist das auf zwei sehr verschiedene Arten möglich.
	Sehen wir uns das näher an \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Varianten}
\enableintroslides{}

==== Initialisierung von Strings ====
{\Large
    \uncover<3->{Variante \glqq{}Mit Array\grqq{}\\}
    \ind{}\texttt{char a[] = ``Hallo'';}\\
    \uncover<2->{\ind{}\texttt{sizeof(a) = sizeof(char)*(5 + 1)}\\}
    \uncover<4->{\ind{}Inhalt les- und schreibbar\\}
~\\
    \uncover<5->{Variante \glqq{}Nur Pointer\grqq{}\\}
    \uncover<6->{\ind{}\texttt{\only<9->{\highlight{const} }char * p = ``Hallo'';}\\}  % gcc -Wwrite-strings
    \uncover<7->{\ind{}\texttt{sizeof(p) = sizeof(char *)}\\}
    \uncover<8->{\ind{}Inhalt \emph{nicht} schreibbar\\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Hier initialisieren wir einen String $a$ mit \glqq{}Hallo\grqq{}.
	im Speicher belegt a dann 5 + 1 Byte, 5 Byte für jeden
	Buchstaben, 1 Byte extra für den Nullterminator.

	Diese Variante möchte ich \glqq{}Mit Array\grqq{} nennen.
	$a$ ist ein vollwertiges Array: der String in $a$ ist les- und schreibbar.

	Die Zweite Variante nenne ich \glqq{}Nur Pointer\grqq{}.
	Ihre Syntax ist anders: wir deklarieren hier einen
	ganz normalen Pointer $p$.  Das ist $p$ auch im Hinblick auf
	seine Größe: ein ganz normaler Pointer: auf einer amd64-Machine
	8 Byte groß.  Der String hinter $p$ liegt in einem besonderem,
	schreibgeschützten Scheichersegment und ist daher \emph{nicht} schreibbar.

	Weil sein Inhalt nicht schreibbar ist, fehlt Aus Sicht der
	Const Correctness bei dieser Variante auch ein \texttt{const}.

	Schauen wir uns dazu noch einmal etwas Code an \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Beispielcode}
\enableintroslides{}


==== Variante \glqq{}Nur Pointer\grqq{} ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
int main() \{\\
~~char * a = ``hallo'';\\
~~char * b = ``hallo'';\\
~\\
~~\uncover<2->{printf(``a=\%p$\backslash$n''\\
~~~~~~~~~``b=\%p$\backslash$n'', a, b);\\
~\\
~~\uncover<3->{a[0] = `X';\\}}
~\\
~~return 0;\\
\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Hier definieren wir zwei Strings in der Variante \glqq{}Nur Pointer\grqq{},
	beide mit dem Text \glqq{}hallo\grqq{}.

	Dann geben wir ihre Adressen aus.
	Zur Erinnerung: \texttt{\%p} im Format-String steht für Pointer.
	Für ihren Inhalt hätten wir \texttt{\%s} geschrieben.

	Danach überschreiben wir den ersten Buchstaben von $a$ mit
	einem großen \glqq{}X\grqq{}.  Schauen wir uns an, was passiert \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Ausgabe}
\enableintroslides{}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,rombad.c~\,-o rombad\\
    \uncover<2->{\# ./rombad\\
    \uncover<3->{a=0x\alt<4>{\highlight{80484dc}}{80484dc}\\
    b=0x\alt<4>{\highlight{80484dc}}{80484dc}\\
    \uncover<5->{\highlight{Segmentation fault}}}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kompilieren, ausführen, \ldots{} da sind $a$ und $b$.

	Wie Sie sehen --- sie haben dieselbe Adresse!

	$a$ und $b$ zeigen also auf den gleichen Speicherbereich.
	Wenn wir nun den Text hinter $a$ verändern, ändert sich auch $b$.

	Aber dazu kommt es nicht: Es knallt --- wir bekommen einen
	Segmentation Fault.

	Dieser Speicher ist nicht schreibbar, ich sagte es ja bereits.

	Warum warnt uns der Compiler nicht?
	Wir hatten ihn bisher nicht darum gebeten.
	Tun wir das doch mal \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Compiler-Warnungen}
\enableintroslides{}


==== GCC Flag \texttt{-Wwrite-strings} ====
{\ttfamily\large
    \# gcc~\,-Wall -Wextra \highlight{-Wwrite-strings} $\backslash$\\
    ~~~~~~rombad.c~\,-o rombad\\
    \uncover<2->{rombad.c: In function `main':\\
    rombad.c:4: warning: initialization discards\\
    ~~~~qualifiers from pointer target type\\
    rombad.c:5: warning: initialization discards\\
    ~~~~qualifiers from pointer target type}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Compilieren wir also noch einmal.
	\texttt{-Wall} und \texttt{-Wextra} möchte ich generell empfehlen,
	für dieses Beispiel wird aber noch \texttt{-Wwrite-strings} benötigt.
	Ja, wirklich.

	Und da sind die Warnungen, die wir erwarten können.
	\glqq{}discards qualifiers\grqq{} bedeutet: Da fehlt \texttt{const}.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Variante \glqq{}Nur Pointer\grqq{} ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
int main() \{\\
~~\only<2->{\alt<2>{\highlight{const}}{const}~}char * a = ``hallo'';\\
~~\only<2->{\alt<2>{\highlight{const}}{const}~}char * b = ``hallo'';\\
~\\
~~printf(``a=\%p$\backslash$n''\\
~~~~~~~~~``b=\%p$\backslash$n'', a, b);\\
~\\
~~\alt<3>{\highlight{a[0] = `X';}}{a[0] = `X';}\\
~\\
~~return 0;\\
\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	So sah unser Code eben aus.

	Hier gehört eigentlich \texttt{const} hin.

	Wenn wir dieses \texttt{const} einfügen, merkt der Compiler
	hier unten, dass wir böse Dinge tun, und verbietet uns das.

	Damit wissen Sie jetzt ausgezeichnet Bescheid über die
	Initialisierung von Strings.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Mehrdimensionale Arrays ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Für die Repräsentation von mehrdimensionalen Arrays
	gibt es in C zwei Varianten, die sich stark unterscheiden.

	Wenn man über diesen Unterschied stolpert, steht man relativ
	im Dunklen: Zu diesem Thema schweigen tielweise auch dickere
	C-Bücher.  Im Internet dazu etwas zu finden, ist auch nicht
	einfach.

	Nicht zuletzt auch, weil ich dieses Thema spannend finde,
	möchte ich daher kurz auf diese zwei Repräsentationen eingehen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Überblick}
\enableintroslides{}


==== Mehrdimensionale Arrays ====
{\LARGE
Zwei Varianten:
* Array von Arrays (\glqq{}deep array\grqq{})
* linear (\glqq{}flat array\grqq{})
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Mehrdimensionale Arrays sind im Speicher entweder
	ein Array von Arrays (\emph{deep arrays}) oder linear ---
	quasi ein-dimensional --- (\emph{flat arrays}).
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

[frame]>


{
\disableintroslides{}
% Subsection mag keine Linebreaks...
\subsection{Variante \glqq{}Array von Arrays\grqq{}}
\introslide{Variante\\\glqq{}Array von Arrays\grqq{}}
\enableintroslides{}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Schauen wir uns zuerst die Variante \glqq{}Array von Arrays\grqq{} an.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== 2D-Array als Array von Arrays ====
<[center]
\mode<beamer>{
\only<1>{
<<<graphics/array-deep-minus-4,height=0.7\textheight>>>
}\only<2>{
<<<graphics/array-deep-minus-3,height=0.7\textheight>>>
}\only<3>{
<<<graphics/array-deep-minus-2,height=0.7\textheight>>>
}\only<4>{
<<<graphics/array-deep-minus-1,height=0.7\textheight>>>
}\only<5>{
<<<graphics/array-deep-minus-0,height=0.7\textheight>>>
}
}
\mode<handout>{
<<<graphics/array-deep-minus-0-black,height=0.7\textheight>>>
}
[center]>
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Speichern wollen wir eine $2\times3$ Matrix, also ein Array
	mit 2 Zeilen und 3 Spalten.

	Bei dieser Variante liegen beide Zeilen als je ein 1D-Array
	im Speicher.

	Oben drauf setzen wir dann ein 1D-Array aus Pointern,
	die auf die Zeilen zeigen.  Dieses Zeilen-Pointer-Array
	ist das eigentliche Array, hier $a$ genannt.

	\texttt{a[0]} zeigt auf die erste Zeile, \texttt{a[1]} auf die zweite.

	Hier unten sitzt \texttt{a[1][2]}.

	Im Code sieht das dann so aus: \ldots{}
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== 2D-Array als Array von Arrays ====
{\ttfamily\Large
    \uncover<4->{void demo\_deep(\highlight{int *} const \highlight{* a}) \{\\
    ~~a[1][2] *= 2;\\
    \}\\}
~\\
    int main() \{\\
    \uncover<2->{~~int row0[] = \{0, 1, 2\};\\
    ~~int row1[] = \{3, 4, 5\};\\
    ~~int * const d[] = \{row0, row1\};\\
    \uncover<3->{~~demo\_deep(d);\\}}
    ~~return 0;\\
    \}\\
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Wieder das Gerüst, dann definieren wir die zwei Zeilen
	und dann das Zeilen-Pointer-Array.

	Dieses Array $d$ kann ich dann an eine Funktion \texttt{demo\_deep}
	übergeben.

	Diese Funktion tut nicht viel Sinnvolles:
	sie verändert einfach einen der Einträge unserer Matrix.

	Das const habe ich eingefügt, weil \texttt{demo\_deep} sonst erlaubt
	wäre, die Struktur der Matrix zu verändern, zum Beispiel
	Zeilen der Matrix zu vertauschen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


=== Variante \glqq{}Linear\grqq{} ===
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Die Variante \glqq{}linear\grqq{} sieht im Speicher völlig anders aus:
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== 2D-Array linear ====
<[center]
\mode<beamer>{
\only<1>{
<<<graphics/array-flat-minus-3,height=0.7\textheight>>>
}\only<2>{
<<<graphics/array-flat-minus-2,height=0.7\textheight>>>
}\only<3>{
<<<graphics/array-flat-minus-0,height=0.7\textheight>>>
}}
\mode<handout>{
<<<graphics/array-flat-minus-0-black,height=0.7\textheight>>>
}
[center]>
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	\ldots{} Beide Zeilen liegen an einem Stück hintereinander
	im Speicher.

	$a$ zeigt auf das erste Element.
	Die Ausdrücke \texttt{a[0]}, \texttt{a[1]}, \texttt{a[1][2]} funktionieren wie
	erwartet, dereferenzieren aber nicht wie erwartet.

	$a$ ist kein Doppelpointer.  Wäre er das, müsste bei $a$ im
	Speicher ein Pointer liegen.  Dort liegt aber ein Datum
	unseren Matrix.

	Wie sieht das im Code aus?
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== 2D-Array linear ====
{\ttfamily\Large
    \uncover<4->{void demo\_flat(\highlight{int a[][3]}) \{\\
    ~~a[1][2] *= 2;\\
    \}\\}
~\\
    int main() \{\\
    \uncover<2->{~~int f[][3] = \{ \{0, 1, 2\},\\
    ~~~~~~~~~~~~~~~~~\{3, 4, 5\} \};\\
    \uncover<3->{~~demo\_flat(f);\\}}
    ~~return 0;\\
    \}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Wir initialisieren die Matrix in einem Stück \ldots{}
	und übergeben sie dann dan \texttt{demo\_flat}.

	Auffällig ist der Paramater $a$ dieser Funktion:
	das ist kein Doppelpointer.  Und die 3 ist nötig,
	damit der Code kompiliert.  Der Kompiler weiß sonst nicht,
	wieviele Elemente er für eine Zeile überspringen muss.

	Das bedeutet auch, dass wir bei dieser Variante zur Zeit der
	Kompilierung wissen müssen, wie groß das Array sein soll.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


=== Variante \glqq{}Hybrid\grqq{} ===
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Eine dritte \glqq{}hybride\grqq{} Variante ergibt sich, wenn man beide
	Varianten kombiniert.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== 2D-Array-Hybrid ====
{\ttfamily\Large
    \uncover<5->{void demo\_deep(\highlight{int *} const \highlight{* a});\\
    void demo\_flat(\highlight{int a[][3]});\\}
~\\
    int main() \{\\
    \uncover<2->{~~int f[][3] = \{ \{0, 1, 2\},\\
    ~~~~~~~~~~~~~~~~~\{3, 4, 5\} \};\\
    \uncover<3->{~~int * const d[] = \{f[0], f[1]\};\\
    \uncover<4->{~~demo\_deep(d);\\
    ~~demo\_flat(f);\\}}}
    ~~return 0;\\
    \}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Wir initialisieren $f$ als Flat Array wie zuvor.

	Oben drauf setzen wir dann ein Zeilen-Pointer-Array,
	das in $f$ zeigt.  Die Ausdrücke \texttt{f[0]} und \texttt{f[1]} liefern,
	was wir dazu brauchen.

	Das resultierende Array $d$ ist mit unserer früheren
	Funktion \texttt{demo\_deep} kompatibel, während $f$ selbst weiterhin
	\texttt{demo\_flat} bedienen kann.

	Zur Erinnerung: So sahen die Prototypen aus.

	Fragen hierzu würde ich aus Zeitgründen gern erst am Ende
	des Vortrags oder nach dem Vortrag klären.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== \texttt{argc} und \texttt{argv} ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Zu guter Letzt möchte ich vorstellen, wie man auf
	Programmargumente zugreifen kann, die beim Aufruf
	übergeben wurden.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Beispielcode}
\enableintroslides{}


==== \texttt{argc} und \texttt{argv} ====
{\ttfamily\Large
    \#include <stdio.h>\\
~\\
    int main(\only<2->{int argc, char ** argv}) \{\\
    \uncover<4->{~~int i = 0;\\}
    \uncover<3->{~~printf(``\%d parameters$\backslash$n'', argc - 1);\\}
    \uncover<4->{~~for (; i < argc; i++) \{\\
    \uncover<5->{~~~~printf(``[\%d] \%s$\backslash$n'', i, argv[i]);\\}
    ~~\}\\}
    ~~return 0;\\
    \}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Das ist die \texttt{main()}-Funktion, wie Sie sie inzwischen
	dutzende Male gesehen habt.

	Das hier ist eine Alternative, die Zugriff auf Programmargumente
	erlaubt.

	Für die, die wissen, was Overloading ist:
	Mit Overloading hat das nichts zu tun --- C unterstützt kein Overloading.

	\texttt{argc} ist die Anzahl der Parameter, die wir übergeben bekommen:
	es ist die Anzahl der Einträge in \texttt{argv}.

	Weil das erste Element unser Programmename ist, gibt es also
	\texttt{argc - 1} echte Parameter.

	In einer Schleife laufen wir über das Array, dass ein echtes
	\glqq{}Deep Array\grqq{} aus Zeilen-Pointern ist.

	\texttt{argv[i]} ist vom Typ \texttt{char *}, was hier nullterminierte Strings sind.
	Diese übergeben wir direkt an \texttt{printf()}.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Ausgabe}
\enableintroslides{}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,print\_args.c~\,-o print\_args\\
    \uncover<2->{\# ./print\_args~free 'open source' software\\}
    \uncover<3->{3 parameters\\
    {}[0] ./print\_args\\
    {}[1] free\\
    {}[2] open source\\
    {}[3] software\\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kompilieren, ausführen, \ldots{} 3 Parameter.

	Die Shell hat wegen der Anführungszeichen \glqq{}open\grqq{} und \glqq{}source\grqq{}
	als ein Element verstanden.

	Element 0 enthält den Namen des Programms, so wie es
	aufgerufen wurde.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Weiterführende Themen ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Weiterführende Themen: Ein paar Dinge habe ich absichtlich
	ausgelassen:
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

==== Weiterführende Themen ====
{\Large
* Character Encodings, Unicode, \texttt{wchar\_t}
* Sicherer Umgang mit Strings
* Der Typ \texttt{size\_t}
* Void-Pointer
* Funktions-Pointer
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	\ldots{} Wir haben uns nicht mit Character Encodings und Unicode
	beschäftigt.  Für uns war Text ASCII-enkodiert.
	Das ist nicht immer so.

	Die dynamische Längenberechnung von Strings kann zu einem
	Sicherheits-Problem werden, wenn man nicht sorgfältig damit
	umgeht.  Auch das haben wir ausgeblendet.

	Der Rückgabetyp unserer Funktion \texttt{my\_strlen} hätte \texttt{size\_t}
	sein sollen, nicht int.  Was es damit auf sich hat,
	hat hier keinen Platz mehr gefunden.

	Auch Void- und Funktions-Pointer haben wir außen vorgelassen.
	Beides sind einfache Themen, die Sie sich schnell selbst
	aneignen lassen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Zusammenfassung ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Wir haben aber auch viel geschafft.
	Wir haben neue Grundlagen aufgebaut und einige Stolpersteine
	umgedreht.

	Was Sie unbedingt mitnehmen müssen:
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Zusammenfassung ====
{\Large
* \texttt{sizeof(\emph{x})} liefert die Größe von \texttt{\emph{x}} in Byte
* Operator \texttt{\&} liefert eine Adresse
* Operator \texttt{*} folgt einer Adresse\\\hfill{}(er \emph{dereferenziert})
* Pointer sind typisiert
* Arrays sind Pointer auf ihr erstes Element
* Strings sind nulltermininiert
* Const Correctness bei Pointern ist \emph{keine}\\\hfill{}Geschmacksfrage
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	\ldots{} sizeof(x) liefert die Größe von x in Byte.

	Der Operator \& liefert eine Adresse, der Operator * dagegen
	folgt einer Adresse.  Man sagt er dereferenziert.

	Pointer sind typisiert.  Wir haben gesehen, wie sich die
	Pointer-Arithmetik das zu nutze macht.

	Arrays sind auch Pointer auf ihr erstes Element.
	Sie erinnern sich an die Formel von vorhin: \texttt{a[k] = *(a + k)}.

	Strings sind nullterminiert, ihre Größe wird dynamisch
	berechnet.  Auch das haben wir uns genau angesehen.

	Const Correctness bei Pointern ist mehr als nur Geschmack,
	sondern macht einen echten Unterschied.

	Wenn Sie das, was auf dieser Folie steht, wirklich verstanden
	habem, vielleicht sogar anderen erklären können, dann bin ich
	stolz darauf, Ihnen das beigebracht zu haben.

}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Eine Bitte ====
{\LARGE
Veröffentlichen Sie Ihren Code\\[1ex]
als Freie Software.
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Eine letzte Bitte an Sie: veröffentlichen Sie den Code,
	den Sie schreiben, als Freie Software.  Für Fragen
	zu diesem Thema bin ich immer zu haben.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== ====
<[center]
{\Huge
Danke!\\
~\\
Zeit für Ihre Fragen!\\
\vfill
\vfill
}
{\LARGE http://blog.hartwork.org/}
[center]>
\vspace*{-4ex}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Damit bedanke ich mich für eure Aufmerksamkeit.

	Zeit für Ihre Fragen!
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
