% Copyright (C) 2009 Sebastian Pipping <sebastian@pipping.org>
% Licensed under Creative Commons Attribution-ShareAlike 3.0 License
%
\newcommand{\ind}{\hspace*{3ex}}
\setbeamertemplate{footline}{\vspace*{-2cm}\hfill\Large\insertpagenumber\vspace*{0.5ex}\hspace*{0.5ex}}
\newcommand{\highlight}[1]{{\color{yellow} #1}}
\newcommand{\exclamation}{!}
\newcommand{\comment}[1]{}
\newcommand{\introslide}[1]{
    {\setbeamertemplate{footline}{}
        \begin{frame}%<beamer>
            \frametitle{}
            \begin{center}\Huge
                #1
            \end{center}
        \end{frame}
    }
}
\AtBeginSection[] % Do nothing for \section*
{
    \introslide{\insertsection}
}
\AtBeginSubsection[] % Do nothing for \subsection*
{
    \introslide{\insertsubsection}
}


==== C-Kurs ====
{\Large
\begin{tabular}{ll@{~~~}l}
~        & Mi  & Konzepte, Syntax, ... \\
~        & ~   & printf, scanf \\[1ex]
Next --> & Do  & Pointer, Arrays, ... \\
~        & ~   & Compiler, Headers, ... \\[1ex]
~        & Fr  & Structs, malloc, ... \\
~        & ~   & Debugging I, ... \\
~        & ~   & + Vorstellung der Aufgabe \\[3ex]
~        & Mo  & Lösung der Aufgabe \\[1ex]
~        & Di  & Debugging II \\
~        & ~   & stdlib, Bücher, ... \\
\end{tabular}
}

==== ====
{\Huge
<[center]
Ohne Pointer geht nichts.
[center]>
}


==== Themen ====
{\large
* Hello pointer
* Call by Reference
* Pointer auf Pointer
* Arrays und Pointer
* Pointer-Arithmetik
* Strings und Längenberechnung
* const correctness
* argc und argv
* Mehrdimensionale Arrays
* Initialisierung von Strings
* NULL-Pointer\vspace*{1ex}
* Weiterführende Themen
* Zusammenfassung
}
%* Strings versus "Memory"


== Pointer ==


==== Variablen im RAM ====
<[center]
\vspace*{-5ex}%
\only<1>{
<<<graphics/ram-minus-3,height=0.95\textheight>>>
}\only<2>{
<<<graphics/ram-minus-2,height=0.95\textheight>>>
}\only<3>{
<<<graphics/ram-minus-1,height=0.95\textheight>>>
}\only<4>{
<<<graphics/ram-minus-0,height=0.95\textheight>>>
}
[center]>


==== ====
{\LARGE
\glqq{}Pointer\grqq{} kann meinen eine...\\[1ex]
\begin{itemize}
\item[A)]$\,$\uncover<2->{Adresse}\\
\item[B)]$\,$\uncover<3->{Variable, die eine Adresse speichert}
\end{itemize}
}


== Hello pointer ==

==== Hello pointer ====
{\ttfamily\large
    \#include <stdio.h>\\
~\\
    int main() \{\\
    \uncover<2->{~~int i = 3;\\}
    \uncover<3->{~~int* p = \&i;\\}
~\\
    \uncover<4->{~~printf(``i == \%d, p == \%p$\backslash$n'', i, p);\\}
~\\
    \uncover<5->{~~*p = 14;\\
    ~~printf(``i == \%d$\backslash$n'', i);\\}
~\\
    ~~return 0;\\
    \}
}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,hello\_pointer.c~\,-o hello\_pointer\\
    \uncover<2->{\# ./hello\_pointer\\
    \uncover<3->{i == 3, p == 0xbfa3ad8c\\
    \uncover<4->{i == 14}}}
}


==== Zusammenfassung 1/2 ====
{\LARGE
*$\,$\uncover<1->{Jede Variable hat eine Adresse}
*$\,$\uncover<2->{Operator \texttt{\&} liefert diese Adresse}
*$\,$\uncover<3->{Operator \texttt{*} folgt einer Adresse\\\ind{}(er \emph{dereferenziert})}
*$\,$\uncover<4->{\texttt{\&} und \texttt{*} sind komplementär; es gilt:\\\ind{}\texttt{*(\&x) == x}}
}


==== Zusammenfassung 2/2 ====
{\LARGE
Pointer zeigen auf typisierte Daten:\\[1ex]
\ind{}\texttt{~int*} == Pointer auf int\\[1ex]
\ind{}\texttt{char*} == Pointer auf char
}


== Call by Reference ==

==== Call by Reference ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
\uncover<4->{void by\_value~~~~(int~~j) \{~~j += 3; \}\\
void by\_reference(int* p)~\{~*p += 4; \}}\\
~\\
int main() \{\\
~~int i = 0;\\
~\\
~~\uncover<2->{by\_value(i);\\
~~by\_reference(\&i);}\\
~\\
~~\uncover<3->{printf(``i == \%d$\backslash$n'', i);}\\
~\\
~~return 0;\\
\}
}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,call\_by\_reference.c $\backslash$\\
    ~~~~~~-o call\_by\_reference\\
    \# ./call\_by\_reference\\
    i == 4
}


== Pointer auf Pointer ==

==== Pointer auf Pointer ====
{\ttfamily\Huge
    int i = 3;\\
    int* p = \&i;\\[1ex]
    \uncover<2->{int** pp = \&p;}
}


== Arrays und Pointer ==

==== Arrays und Pointer~~(1/3) ====
{\ttfamily
    \#include <stdio.h>\\
~\\
    int main() \{\\
    \uncover<2->{~~int primes[] = \{2, 3, 5, 7, 11\};\\}
    \uncover<3->{~~int i;\\}
~\\
    \uncover<4->{~~for (i = 0; i < 5; ++i) \{\\
    \uncover<5->{~~~~printf(``primes[\%d] == \%d$\backslash$n'', i,\\
    ~~~~~~~~primes[i]);\\}
    ~~\}\\}
    ~~return 0;\\
    \}
}


==== Zusammenfassung ====
{\LARGE
<[center]
Zugriff via [\emph{n}] ähnlich Java
[center]>
}


==== Arrays und Pointer~~(2/3) ====
{\ttfamily
    \#include <stdio.h>\\
~\\
    int main() \{\\
    ~~int primes[] = \{2, 3, 5, 7, 11\};\\
    ~~int i;\\
~\\
    ~~for (i = 0; i < \only<1>{5}\only<2->{\highlight{sizeof(primes) / sizeof(int)}}; ++i) \{\\
    ~~~~printf(``primes[\%d] == \%d$\backslash$n'', i,\\
    ~~~~~~~~primes[i]);\\
    ~~\}\\
    ~~return 0;\\
    \}
}


==== Zusammenfassung~~(1/2) ====
{\Large
<[center]
\texttt{sizeof(\emph{variable})\\==}\\
Von \texttt{\emph{variable}} belegter Speicher in Byte
[center]>
}


==== Zusammenfassung~~(2/2) ====
{\Large
<[center]
\texttt{sizeof(\highlight{\emph{type}})\\==}\\
Von \highlight{\texttt{\emph{type}}-Instanzen} belegter Speicher in Byte
[center]>
}


==== Arrays und Pointer~~(3/3) ====
{\ttfamily
    \#include <stdio.h>\\
~\\
    int main() \{\\
    ~~int primes[] = \{2, 3, 5, 7, 11\};\\
    ~~int i;\\
~\\
    ~~for (i = 0; i < sizeof(primes) / sizeof(int); ++i) \{\\
    ~~~~printf(``primes[\%d]\only<3->{ via array~~} == \%d$\backslash$n'', i,\\
    ~~~~~~~~\only<1-4>{primes[i]}\only<5->{\highlight{{primes[i]}}});\\
    \only<2->{\uncover<4->{~~~~printf(``primes[\%d] via pointer == \%d$\backslash$n'', i,\\
    ~~~~~~~~\only<4>{*(primes + i)}\only<5->{\highlight{*(primes + i)}});\\}}
    ~~\}\\
    ~~return 0;\\
    \}
}


==== Zusammenfassung~~(1/2) ====
{\LARGE
<[center]
Array~\,\texttt{==}\,~Pointer auf den Anfang des Arrays
[center]>
}

==== Zusammenfassung~~(2/2) ====
{\ttfamily\Huge
<[center]
\emph{a}[\emph{n}]~==~*(\emph{a} + \emph{n})
[center]>
}


== Pointer-Arithmetik ==

==== Pointer-Arithmetik ====
{\Large
    {\ttfamily
        int numbers[3];\\
        char text[] = ``software libre'';\\
    }
~\\
    \uncover<2->{Es gilt:\\
    {\ttfamily
        \ind{}numbers[i] == *(numbers + i)\\
        \uncover<3->{\ind{}text[j] == *(text + j)\\}
        \uncover<4->{\ind{}sizeof(char) != sizeof(int)\\}
    }
~\\
    \uncover<5->{Für Operatoren +/- auf Pointern folgt:\\}
    \uncover<6->{\ind{}Sprungweite variiert mit dem Typen!\\}}
}


== Strings ==

==== Strings ====
{\LARGE
    ``ABC''\uncover<2->{~ --> ~\{\,65, 66, 67, \underline{00}\,\}\\
~\\[1ex]
    \uncover<3->{{\ttfamily
        \#include <string.h>\\
        ...\\
        strlen(``ABC'');\\[1ex]
    }
    \uncover<4->{ --> 3\\}}}
}

==== my\_strlen ====
{\ttfamily\LARGE
    unsigned int\\
    my\_strlen(const char *str) \{\\
    \uncover<2->{~~const char *walker = str;\\}
    \uncover<3->{~~while (\only<3,6->{'$\backslash$0' \exclamation{}= *walker}\only<4>{\highlight{*walker}}\only<5>{\highlight{'$\backslash$0' \exclamation{}= }*walker}) \{\\
    ~~~~walker++;\\
    ~~\}\\}
    ~~return \uncover<6->{\highlight{walker - str}};\\
    \}
}


==== Strings ====
{\ttfamily\LARGE
    strlen(``ABC'');\\
    \uncover<2->{ --> 3\\[1ex]}
    \uncover<3->{strlen(``A$\backslash$0B$\backslash$0C'');\\}
    \uncover<4->{ --> 1\\[1ex]}
    \uncover<5->{strlen(``ABC$\backslash$0$\backslash$0'');\\}
    \uncover<6->{ --> 3\\}
}


== const correctness ==

==== const correctness~~(1/7) ====
{\LARGE
<[center]
char \only<1>{const}\only<2>{\highlight{const}} * \only<1>{const}\only<2>{\highlight{const}} foo = ``foo'';
[center]>
}

==== const correctness~~(2/7) ====
{\ttfamily\LARGE
~~\underline{~~~~~} int \underline{~~~~~} foo;
}

==== const correctness~~(3/7) ====
{\ttfamily\LARGE
~~int const~~x = 3;\\
~\\
~~const int~~y = 4;
}

==== const correctness~~(4/7) ====
{\ttfamily\LARGE
~~\underline{~~~~~}~int~\underline{~~~~~}\only<2->{~*~\underline{~~~~~}}~foo;\\
~~\uncover<4->{~~|~~~~~~~~~|~~~~~}\uncover<3->{~~|\\}
~~\uncover<4->{~<2a>~~~~~~<2b>~~~}\uncover<3->{~<1>\\}
}

==== const correctness~~(5/7) ====
{\ttfamily\LARGE
    <1>~~int * const foo;\\
    \uncover<2->{~~~~~~~\textsf{Verbietet:}\\
    ~~~~~~~foo = ...;\\
~\\
    \uncover<3->{<2a> const int *foo;\\
    <2b> int const *foo;\\
    \uncover<4->{~~~~~~~\textsf{Verbietet:}\\
    ~~~~~~~foo[3] = ...;\\}}}
}

==== const correctness~~(6/7) ====
{\ttfamily\LARGE
    <2a,1> int const * const foo;\\
    \uncover<2->{~~~~~~~\textsf{Verbietet:}\\
    ~~~~~~~foo = ...;\\
    ~~~~~~~foo[5] = ...;\\
~\\
\uncover<3->{\highlight{\textsf{String-Konstanten bitte immer so!}}\\[1ex]}}
\uncover<4->{\highlight{char const * const foo = ``foo'';}}
}

==== const correctness~~(7/7) ====
{\ttfamily\LARGE
    int const * const * const foo;\\
    \uncover<2->{~~~~~~~\textsf{Verbietet:}\\
    ~~~~~~~foo = ...;\\
    ~~~~~~~foo[7] = ...;\\
    ~~~~~~~foo[2][4] = ...;\\}
}


==== const correctness in APIs ====
{\Large
    \texttt{int my\_strlen(char *str);\\}
    \uncover<2->{\ind{}Funktion darf \emph{Inhalt} von \texttt{str} verändern\\}
    \uncover<3->{\ind{}my\_strlen(``ABC'') gibt Compile-Fehler\\}
~\\
    \texttt{int my\_strlen(\underline{const} char *str);\\}
    \uncover<4->{\ind{}Funktion darf Inhalt von \texttt{str} \emph{nicht} verändern\\}
    \uncover<5->{\ind{}my\_strlen(``ABC'') erlaubt und sicher\\}
}


== argc und argv ==

==== argc und argv ====
{\ttfamily\Large
    \#include <stdio.h>\\
~\\
    int main(\only<2->{int argc, char **argv}) \{\\
    \uncover<4->{~~int i = 0;\\}
    \uncover<3->{~~printf(``\%d parameters$\backslash$n'', argc - 1);\\}
    \uncover<4->{~~for (; i < argc; ++i) \{\\
    \uncover<5->{~~~~printf(``[\%d] \%s$\backslash$n'', i, argv[i]);\\}
    ~~\}\\}
    ~~return 0;\\
    \}
}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,print\_args.c~\,-o print\_args\\
    \uncover<2->{\# ./print\_args~free 'open source' software\\}
    \uncover<3->{3 parameters\\
    {}[0] ./print\_args\\
    {}[1] free\\
    {}[2] open source\\
    {}[3] software\\}
}


== Mehrdimensionale Arrays ==
{
\subsection*{Variante \glqq{}Array von Pointern\grqq{}}
\introslide{Variante\\\glqq{}Array von Pointern\grqq{}}
}

==== 2D-Array als Array von Pointern ====
<[center]
\only<1>{
<<<graphics/array-deep-minus-4,height=0.7\textheight>>>
}\only<2>{
<<<graphics/array-deep-minus-3,height=0.7\textheight>>>
}\only<3>{
<<<graphics/array-deep-minus-2,height=0.7\textheight>>>
}\only<4>{
<<<graphics/array-deep-minus-1,height=0.7\textheight>>>
}\only<5>{
<<<graphics/array-deep-minus-0,height=0.7\textheight>>>
}
[center]>

==== 2D-Array als Array von Pointern ====
{\ttfamily\Large
    \uncover<4->{void demo\_deep(\highlight{int *} const \highlight{*a}) \{\\
    ~~a[1][2] *= 2;\\
    \}\\}
~\\
    int main() \{\\
    \uncover<2->{~~int row0[] = \{0, 1, 2\};\\
    ~~int row1[] = \{3, 4, 5\};\\
    ~~int * const d[] = \{row0, row1\};\\
    \uncover<3->{~~demo\_deep(d);\\}}
    ~~return 0;\\
    \}\\
}

=== Variante \glqq{}Linear\grqq{} ===

==== 2D-Array linear ====
<[center]
\only<1>{
<<<graphics/array-flat-minus-3,height=0.7\textheight>>>
}\only<2>{
<<<graphics/array-flat-minus-2,height=0.7\textheight>>>
}\only<3>{
<<<graphics/array-flat-minus-1,height=0.7\textheight>>>
}\only<4>{
<<<graphics/array-flat-minus-0,height=0.7\textheight>>>
}
[center]>

==== 2D-Array linear ====
{\ttfamily\Large
    \uncover<4->{void demo\_flat(\highlight{int a[][3]}) \{\\
    ~~a[1][2] *= 2;\\
    \}\\}
~\\
    int main() \{\\
    \uncover<2->{~~int f[][3] = \{ \{0, 1, 2\},\\
    ~~~~~~~~~~~~~~~~~\{3, 4, 5\} \};\\
    \uncover<3->{~~demo\_flat(f);\\}}
    ~~return 0;\\
    \}
}

=== Variante \glqq{}Hybrid\grqq{} ===

==== 2D-Array-Hybrid ====
{\ttfamily\Large
    \uncover<5->{void demo\_flat(\highlight{int a[][3]});\\
    void demo\_deep(\highlight{int *} const \highlight{*a});\\}
~\\
    int main() \{\\
    \uncover<2->{~~int f[][3] = \{ \{0, 1, 2\},\\
    ~~~~~~~~~~~~~~~~~\{3, 4, 5\} \};\\
    \uncover<3->{~~int * const d[] = \{f[0], f[1]\};\\
    \uncover<4->{~~demo\_flat(f);\\
    ~~demo\_deep(d);\\}}}
    ~~return 0;\\
    \}
}

== Initialisierung von Strings ==

==== Initialisierung von Strings ====
{\Large
    \uncover<3->{Variante \glqq{}Mit Array\grqq{}\\}
    \ind{}\texttt{char a[] = ``Hallo'';}\\
    \uncover<2->{\ind{}\texttt{sizeof(a) == sizeof(char)*(5 + 1)}\\}
    \uncover<4->{\ind{}Inhalt les- und schreibbar\\}
~\\
    \uncover<5->{Variante \glqq{}Nur Pointer\grqq{}\\}
    \uncover<6->{\ind{}\texttt{\only<9->{\highlight{const} }char *p = ``Hallo'';}\\}  % gcc -Wwrite-strings 
    \uncover<7->{\ind{}\texttt{sizeof(p) == sizeof(char *)}\\}
    \uncover<8->{\ind{}Inhalt \emph{nicht} schreibbar\\}
}

==== Variante \glqq{}Nur Pointer\grqq{} ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
int main() \{\\
~~char* a = ``hallo'';\\
~~char* b = ``hallo'';\\
~\\
~~\uncover<2->{printf(``a=\%p$\backslash$n''\\
~~~~~~~~~``b=\%p$\backslash$n'', a, b);\\
~\\
~~\uncover<3->{a[0] = `X';\\}}
~\\
~~return 0;\\
\}
}

==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,rombad.c~\,-o rombad\\
    \uncover<2->{\# ./rombad\\
    \uncover<3->{a=\only<3,5->{0x80484dc}\only<4>{0x\highlight{80484dc}}\\
    b=\only<3,5->{0x80484dc}\only<4>{0x\highlight{80484dc}}\\
    \uncover<5->{Segmentation fault}}}
}

==== GCC Flag \texttt{-Wwrite-strings} ====
{\ttfamily\large
    \# gcc~\,-Wall -Wextra \highlight{-Wwrite-strings} $\backslash$\\
    ~~~~~~rombad.c~\,-o rombad\\
    \uncover<2->{rombad.c: In function `main':\\
    rombad.c:4: warning: initialization discards\\
    ~~~~qualifiers from pointer target type\\
    rombad.c:5: warning: initialization discards\\
    ~~~~qualifiers from pointer target type}
}

==== Variante \glqq{}Nur Pointer\grqq{} ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
int main() \{\\
~~\only<2>{\highlight{const~}}\only<3->{const~}char* a = ``hallo'';\\
~~\only<2>{\highlight{const~}}\only<3->{const~}char* b = ``hallo'';\\
~\\
~~printf(``a=\%p$\backslash$n''\\
~~~~~~~~~``b=\%p$\backslash$n'', a, b);\\
~\\
~~\only<3>{\highlight{a[0] = `X';}}\only<-2,4->{a[0] = `X';}\\
~\\
~~return 0;\\
\}
}


%==== Strings versus "Memory" ====
\comment{\Large
    \underline{str}ncpy(\underline{char} *dest, const \underline{char} *src, size\_t n);\\[1.5ex]
    \underline{mem}cpy(\underline{void} *dest, const \underline{void} *src, size\_t n);\\[0.5ex]
    \uncover<2->{ohne Null-Byte-Behandlung}
}


== NULL-Pointer ==

==== NULL-Pointer ====
{\ttfamily\Large
    \#include <stdlib.h>~~/* for NULL */\\
    ...\\
    int *p = NULL;\\
    \uncover<2->{...\\
    int b = *p;\uncover<3->{\textsf{~\highlight{ <-- BANG!}}}\\}
}


== Weiterführende Themen ==

==== Weiterführende Themen ====
{\Large
* Character encodings, Unicode, wchar\_t
* Sicherer Umgang mit Strings
* Der Typ size\_t
* Void-Pointer
* Funktions-Pointer
}


== Zusammenfassung ==

==== Zusammenfassung ====
{\Large
* \texttt{sizeof(\emph{x})} liefert die Größe von \texttt{\emph{x}} in Byte
* \&-Operator liefert eine Adresse
* *-Operator dereferenziert
* Pointer sind typisiert
* Arrays sind auch Pointer auf ihr erstes Element
* Strings sind nulltermininiert
* const correctness bei Pointern ist wichtig
}


==== ====
<[center]
{\Huge
Danke!\\
~\\
Fragen?\\
\vfill
\vfill
}
{\LARGE http://blog.hartwork.org/}
[center]>
\vspace*{-4ex}