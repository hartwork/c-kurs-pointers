% Copyright (C) 2009 Sebastian Pipping <sebastian@pipping.org>
% Licensed under Creative Commons Attribution-ShareAlike 3.0 License
%
\newcommand{\ind}{\hspace*{3ex}}
\setbeamertemplate{footline}{\vspace*{-2cm}\hfill\Large\insertpagenumber\vspace*{0.5ex}\hspace*{0.5ex}}
\newcommand{\highlight}[1]{{\color{yellow} #1}}
\newcommand{\exclamation}{!}
\newcommand{\comment}[1]{}
\newcommand{\introslide}[1]{
    {\setbeamertemplate{footline}{}
        \begin{frame}%<beamer>
            \frametitle{}
            \begin{center}\Huge
                #1
            \end{center}
        \end{frame}
    }
}


\newcommand{\enableintroslides}[0]{
	\AtBeginSection[] % Do nothing for \section*
	{
		\introslide{\insertsection}
	}
	\AtBeginSubsection[] % Do nothing for \subsection*
	{
		\introslide{\insertsubsection}
	}
}

\newcommand{\disableintroslides}[0]{
	\AtBeginSection[] % Do nothing for \section*
	{}
	\AtBeginSubsection[] % Do nothing for \subsection*
	{}
}

\enableintroslides{}



%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
%	Willkommen zum zweiten Tag des C-Kurses.
%	Mein Name ist Sebastian Pipping.  In der nächsten Stunde
%	werde ich versuchen, euch Pointer in C näherzubringen.
%
%	Die Folien und alle Code Beispiele sind übrigens im Netz.
%	Ihr könnt gerne mitschreiben, müsst aber nicht.
%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


\disableintroslides{}
\section{C-Kurs-Fahrplan}
\enableintroslides{}

==== C-Kurs ====
{\LARGE
\hspace*{-1.5ex}\begin{tabular}{ll@{~~~}l}
~        & Di  & Einführung \\
~        & ~   & I/O, Formatierung\\[1ex]
~        & Mi  & Structs, Enums, Unions \\
~        & ~   & Speicherverwaltung\\[1ex]
Next \sexyarrowrightLARGE{} & Do  & Arrays, Strings, Pointer \\
~        & ~   & Präprozessor, Makefiles\\[1ex]
~        & Fr  & Fehlererkennung\\
~        & ~   & Bibliotheken, SDL, SVN \\
\end{tabular}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Gestern haben wir uns mit den Grundbausteinen von C
	und mit Ein- und Ausgabe beschäftigt.
	Dabei haben wir an mehreren Stellen bereits Pointer verwendet.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== ====
{\Huge
<[center]
Ohne Pointer geht nichts.
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Das ist auch nicht weiter verwunderlich:
	Ohne Pointer geht in C wirklich nichts.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== ====
{\LARGE
Pointer sind Grundlage für:
* Arrays
* Strings
* Call by Reference
* Komplexe Datentypen
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Pointer sind die Grundlage für Arrays, Strings,
	Call by Reference und komplexe Datentypen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


\disableintroslides{}
\section{Themen dieser Vorlesung}
\enableintroslides{}

==== Themen ====
{\large
* Hello Pointer
* Call by Reference
* Pointer auf Pointer
* Vom Pointer zum Array
* Pointer-Arithmetik
* Strings, Längencodierung, String API
* Const Correctness
* Initialisierung von Strings
* Mehrdimensionale Arrays
* Programm-Argumente: \texttt{argc} und \texttt{argv}\vspace*{1ex}
* Weiterführende Themen
* Zusammenfassung
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Und weil in C nichts ohne Pointer geht, gibt es -
	die lange Liste an Themen spiegelt das wieder -
	einiges Wichtiges über sie zu erzählen.

	In "Hello Pointer" möchte ich Pointer an einem Minimalbeispiel
	vorstellen:
	- Was ist das Konzept?
	- Wie lautet die Syntax?
	- Wo ist der Bezug zum Arbeitsspeicher?

	Danach möchte unter Verwendung von Pointern Call by Reference
	nachbauen, also Funktionen erlauben, ausgewählten Variablen der
	Welt um sie herum zu verändern.

	Gelegentlich zeigen Pointer auch auf andere Pointer.
	Dazu werde ich ein Beispiel aus der realen Welt vorstellen.

	In "Vom Pointer zum Array" werden wir die Funktionsweise von
	Arrays näher kennenlernen.

	Damit sind wir direkt beim Thema "Pointer-Arithmetik" und
	was sich hinter diesem Begriff verbirgt.

	Aufbauend auf unserem Wissen über Arrays werde ich dann
	Strings als spezielle Arrays vorstellen, wie deren Länge
	codiert wird und welche Konsequenzen das hat.

	Bevor ich die zwei verschiedenen Arten der Initialisierung von
	Strings vorstellen kann, muss ich in "Const Correctness"
	ein paar Grundlagen aufbauen: An ein paar Stellen ist die
	Frage "konstant oder nicht konstant" mehr als nur Geschmack,
	sondern macht einen echten Unterschied.

	Auch für die Repräsentation von mehrdimensionalen Arrays
	gibt es in C zwei Varianten.  Hilfe für diese Stolperfalle
	mit auf den Weg zu geben, ist mir wichtig.

	Mit dem bis dahin aufgebauten Verständnis sind wir dann auch
	in der Lage, Programm-Argumente auszulesen, was	ich mit
	passendem Code demonstrieren werde.

	Danach möchte ich mit einem Ausblick und einer Zusammenfassung
	schließen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


\disableintroslides{}
\section{Definition Pointer}
\enableintroslides{}


==== ====
{\Huge
<[center]
Was ist ein \glqq{}Pointer\grqq{}?
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Also was ist ein "Pointer"?
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== ====
{\LARGE
\glqq{}Pointer\grqq{} kann meinen eine...\\[1ex]
\begin{itemize}
\item[A)]$\,$\uncover<2->{Adresse}\\
\item[B)]$\,$\uncover<3->{Variable, die eine Adresse speichert}
\end{itemize}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	"Pointer" meint entweder eine Adresse oder eine Variable,
	die eine Adresse speichert.  Diese Mehrdeutigkeit ist gar nichts
	wirklich neues: Das Wort "Integer" verwenden wir ganz
	selbstverständlich zum einen für ganze Zahlen - sagen wir die 3 -
	und zum anderen für Variablen die Integer speichern:
	i ist ein Integer.

	"Pointer" meint also eine Adresse oder eine Variable,
	die eine Adresse speichert.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Hello Pointer ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Hello Pointer - lasst uns dazu etwas Code ansehen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Beispielcode}
\enableintroslides{}


==== Hello Pointer ====
{\ttfamily\large
    \#include <stdio.h>\\
~\\
    int main() \{\\
    \uncover<2->{~~int i = 3;\\}
    \uncover<3->{~~int * p = \&i;\\}
~\\
    \uncover<6->{~~printf(``i == \%d, p == \%p$\backslash$n'', i, p);\\}
    \uncover<4->{~~*p = 4;\\}
    \uncover<6->{~~printf(``i == \%d, p == \%p$\backslash$n'', i, p);\\}
    \uncover<5->{~~p = 5;\\}
    \uncover<6->{~~printf(``i == \%d, p == \%p$\backslash$n'', i, p);\\}
~\\
    ~~return 0;\\
    \}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Fangen wir an mit einem Gerüst, dass euch inzwischen
	sehr bekannt vorkommen wollte.

	Wir definieren einen Integer i, bisher nichts Neues.

	Als nächstes definieren wir einen Pointer p, der auf i zeigt.
	der \&-Operator liefert hierbei die Adresse von i.
	p ist vom Typ int *, Pointer auf einen int.

	Danach schreiben wir den Wert 4 nach *p.  Der *-Operator folgt
	der Adresse in p - wir schreiben also effektiv in den Speicher
	von i!

	p selbst ist auch schreibbar - hier schreiben wir den Wert 5.

	Als letztes fügen wir noch ein paar printf()s ein, um die Werte
	von i und p auszugeben.

	Lasst uns das doch mal ausführen...
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Ausgabe}
\enableintroslides{}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,hello\_pointer.c~\,-o hello\_pointer\\
    \uncover<2->{\# ./hello\_pointer\\}
    \uncover<3->{i == 3, p == 0xbfa3ad8c\\}
    \uncover<4->{~~~~~~~~~~~~~~~~~~~~~~~~~|~*p = 4;\\}
    \uncover<5->{i == 4, p == 0xbfa3ad8c\\}
    \uncover<6->{~~~~~~~~~~~~~~~~~~~~~~~~~|~p = 5;\\}
    \uncover<7->{i == 4, p == 0x5\\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Erstmal kompilieren wir das.

	Dann ausführen...

	i ist drei - so wie wir es initialisiert hatten - und p
	zeigt auf i, das an Adresse \glqq{}bfa und weiter\grqq{} liegt.
	Nebenbei: Diese Adresse kann bei jeden Aufruf verschieden sein.

	Zur Erinnerung: Dann kam \texttt{*p = 4;}.

	Weil der *-Operator der Adresse in p folgt, landet die 4 in i.
	p selbst bleibt unverändert.

	Dann kam \texttt{p = 5;}.

	Diesmal wird p selbst verändert: p zeigt jetzt auf Adresse 5.

	Lasst mich das kurz zusammenfassen...
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Zusammenfassung}
\enableintroslides{}


==== Zusammenfassung 1/2 ====
{\LARGE
*$\,$\uncover<1->{Operator \texttt{\&} liefert eine Adresse}
*$\,$\uncover<2->{Operator \texttt{*} folgt einer Adresse\\\ind{}(er \emph{dereferenziert})}
*$\,$\uncover<3->{\texttt{\&} und \texttt{*} sind komplementär; es gilt:\\\ind{}\texttt{*(\&x) = x}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Operator \& liefert eine Adresse.

	Operator * folgt einer Adresse.  Man sagt auch \glqq{}er dereferenziert\grqq{}.

	Besonders für die Mathematiker unter euch:
	Diese beiden Operatoren sind komplementär.
	Wenn ich nach der Adresse von x frage und dann dieser Adresse
	folge erhalte ich wieder x.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Zusammenfassung 2/2 ====
{\LARGE
<[center]
Pointer zeigen auf typisierte Daten:\\[1ex]
\texttt{int *}~~$\neq$~~\texttt{char *}
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Pointer zeigen auf typisierte Daten.
	Es gibt einen Unterschied zwischen Pointern auf ints
	und Pointern auch chars.  Diese Unterscheidung ist die
	Grundlage für Pointer-Arithmetik - dazu später mehr.

	Zuvor möchte ich euch zeigen, wie man mithilfe von Pointern
	Call by Reference in C nachbaut.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Call by Reference ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Zur Erinnerung: Call by Reference bedeutet, einer Funktion
	zu erlauben, ausgewählten Variablen der Welt um sie herum
	zu verändern.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Beispielcode}
\enableintroslides{}


==== Call by Reference ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
\uncover<4->{void by\_value~~~~(int~~~x) \{~~~x += 3;~~\}\\
void by\_reference(int * x)~\{~~*x += 4;~~\}}\\
~\\
int main() \{\\
~~int i = 0;\\
~\\
~~\uncover<2->{by\_value(i);\\}
~~\uncover<5->{printf(``i == \%d$\backslash$n'', i);\\}
~~\uncover<3->{by\_reference(\&i);\\}
~~\uncover<5->{printf(``i == \%d$\backslash$n'', i);\\}
~\\
~~return 0;\\
\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Fangen wir an mit einem bekannten Gerüst: mit einer
	main-Funktion und einem Integer i.

	Übergeben wir i nun an eine Funktion \texttt{by\_value} und
	eine Funktion \texttt{by\_reference}.

	\texttt{by\_value} verändert Paramater x, arbeitet somit auf dem
	einem kopierten Wert von i.

	\texttt{by\_reference} dagegen schreibt in den Speicher der kopierten
	Adresse von \&i und verändert damit den Wert von i.

	Welchen Wert hat i also am Ende von main()?

	<PAUSE>

	Fügen wir noch ein paar printf()s hinzu und lassen es laufen...
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Ausgabe}
\enableintroslides{}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,call\_by\_reference.c $\backslash$\\
    ~~~~~~-o call\_by\_reference\\
    \uncover<2->{\# ./call\_by\_reference\\
    \uncover<3->{i == 0\\
    i == 4}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kompilieren, ausführen, i ist 0 und dann 4.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Pointer auf Pointer ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Auch Pointer auf Pointer, manchmal \glqq{}Doppelpointer\grqq{} genannt,
	werden regelmäßig gebraucht.

	Zum Beispiel für...
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Anwendungen}
\enableintroslides{}


==== Anwendungen ====
{\LARGE
* $\,$Mehrdimensionale Arrays
* $\,$\uncover<2->{Call by Reference \emph{von} Pointern}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	... Mehrdimensionale Arrays oder, wenn Pointer selbst
	mittels Call by Reference verändert werden sollen.

	Eine Funktion, die ihr sicher mal brauchen werdet, macht
	Gebrauch davon: ...
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{man strtod}
\enableintroslides{}


==== man strtod ====
{\ttfamily\large
STRTOD(3)\hfill{}Linux Programmer's Manual\hfill{}STRTOD(3)\\
~\\
NAME\\
\ind{}strtod, strtof, strtold - convert ASCII string\\\hfill{}to floating-point number\\
~\\
SYNOPSIS\\
\ind{}\#include <stdlib.h>\\
~\\
\ind{}double strtod(const char *nptr, \only<1>{char **endptr}\only<2>{\highlight{char **endptr}});\\
\ind{}float strtof(const char *nptr, \only<1>{char **endptr}\only<2>{\highlight{char **endptr}});\\
~\\
\ldots{}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	... die Funktion strtod().

	Hier seht ihr einen Ausschnitt aus der Manpage von
	strtod().

	Unten rechts seht ihr einen Pointer auf einen Pointer.
	strtod() arbeitet mit Call by Reference.
	In einer unserer Übungsaufgaben könnt ihr genau
	mit dieser Funktion herumexperimentieren.

	Wirklich schwer sind Doppelpointer nicht; außer einem weiteren
	Stern erwartet euch syntaktisch nichts Neues.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Beispielcode}
\enableintroslides{}


==== Pointer auf Pointer ====
{\ttfamily\Huge
    int i = 3;\\
    int * p = \&i;\\[1ex]
    \uncover<2->{int ** pp = \&p;}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Das kennt ihr schon: Pointer p wird mit der Adresse von i
	initialisiert.

	p ist ein einfacher Pointer.

	Hier wird nun Doppelpointer pp mit der Adresse von p
	initialisiert: Wir setzen also eine weitere Indirektionsschicht
	oben drauf.

	Wenn ihr euch an meine Darstellung des Arbeitsspeichers
	von vorhin erinnert: das waren i, p und pp.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Variablen im RAM~~(Wiederholung) ====
<[center]
\vspace*{-3ex}%
<<<graphics/ram-minus-0,height=0.94\textheight>>>
[center]>
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Gibt es Fragen bis hierher?
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Vom Pointer zum Array ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	In C hängen Arrays und Pointer zusammen.

	Schauen wir uns an, wie dieser Zusammenhang genau aussieht.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Beispielcode}
\enableintroslides{}


==== Vom Pointer zum Array ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
\uncover<2->{void dump(const int * data, int count) \{\\
~~\uncover<3->{int i = 0;\\
~~for (; i < count; ++i) \{\\
~~~~\uncover<4->{printf(``Field \%d: \%d$\backslash$n'', i + 1, \only<4>{\highlight{*(data + i)}}\only<5>{\highlight{data[i]}}\only<6->{data[i]});}\\
~~\}}\\
\}}\\
~\\
int main() \{\\
~~\uncover<6->{int const primes[] = \{2, 3, 5, 7, 11\only<9>{, \highlight{13}}\};\\
~~\uncover<7->{dump(primes, \only<7>{5}\only<8>{\highlight{sizeof(primes) / sizeof(int)}}\only<9->{sizeof(primes) / sizeof(int)});}}\\
~~return 0;\\
\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Diese Gerüst kennt ihr schon.

	Hier definiere ich eine Funktion \texttt{dump} die Daten ausgeben soll.
	Die Daten sind Integer, die im Speicher direkt
	hintereinanderliegen: ein Array von ints.

	Von diesen ints gibt es count viele, der erste von ihnen
	liegt an Adresse data.

	Was ich jetzt machen kann, ist, mit einer simplen for-Schleife
	über die Daten iterieren und jedes Datum einzeln ausgeben.

	An den jeweiligen Wert gelangen wir, indem wir auf die
	Basisadresse data i drauf addieren und dann der resultierenden
	Adresse folgen.

	Sind alle einverstanden, dass das so funktioniert?
	
	<PAUSE>

	Wenn ihr jetzt denkt, dass diese Syntax unnötig hässlich ist:
	Ihr habt recht, dafür gibt es eine Kurzschreibweise.
	Diese Syntax kennt ihr vermutlich bereits von Java.

	Lasst uns nun die Funktion mit Daten füttern.

	Hier definieren wir ein Array, das die 5 kleinsten Primzahlen
	enthält und rufen dump() damit auf.

	Die Länge des Arrays müssen wir explizit übergeben, weil
	die Funktion dump() einem Pointer allein nicht ansehen kann,
	wie lang das Array dahinter ist: die Länge von Arrays
	mit explizit mitherumgeschleppt werden!

	Dass wir explizit sagen müssen, dass unser Array 5 Einträge
	lang ist, ist etwas unschön.

	Vermeiden lässt sich das hier mithilfe von des sizeof-Operators.
	sizeof erkennt zur Compilezeit, wieviele Byte Speicher sein
	Argument belegt.  Auf meiner 32-Bit-Machine belegt das Array
	primes 20 Byte, ein int belegt 4 Byte.  20 durch 4 sind 5.

	Durch diesen Trick könnten wir nun die sechste Primzahl an
	primes anhängen, ohne den Aufruf von dump() aktualisieren zu
	müssen.

	Lasst mich das eben zusammenfassen...
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Zusammenfassung}
\enableintroslides{}


==== Zusammenfassung~~(1/5) ====
{\LARGE
<[center]
Array-Zugriff via \texttt{[\emph{n}]} ähnlich Java
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Der Array-Zugriff funktioniert mit eckigen Klammern und einem
	Index n wie auch in Java.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Zusammenfassung~~(2/5) ====
{\LARGE
<[center]
Array~\,=\,~Pointer auf das erste Element
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Ein Array ist auch ein Pointer auf sein erstes Element.
	Mit dieser Adresse können wir auch direkt arbeiten,
	zum Beispiel darauf addieren.  Mehr dazu später.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Zusammenfassung~~(3/5) ====
{\ttfamily\Huge
<[center]
\emph{a}[\emph{n}]~\,\textsf{=}\,~*(\emph{a} + \emph{n})
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Die Syntax mit den eckigen Klammern ist eine syntaktische
	Abkürzung.  Eigentlich wird die Adresse des ersten Elements
	genommen, darauf addiert und dann der resultierenden
	Adresse gefolgt.

	Array-Zugriff ist also auch dereferenzieren!
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Zusammenfassung~~(4/5) ====
{\Large
<[center]
\texttt{sizeof(\emph{variable})}\\=\\
Von \texttt{\emph{variable}} belegter Speicher in Byte
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Der Operator sizeof liefert die Anzahl Byte, die eine
	Variable im Speicher belegen wird.

	Diese Auswertung geschieht zur Compilezeit.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Zusammenfassung~~(5/5) ====
{\Large
<[center]
\texttt{sizeof(\highlight{\emph{type}})}\\=\\
Von \highlight{\texttt{\emph{type}}-Instanzen} belegter Speicher in Byte
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Desweiteren kann sizeof auch die Größe von Typen bestimmen:
	wieviele Byte Speicher wird Typ xy belegen.

	sizeof() kann noch ein bisschen mehr, aber weitere Details
	sind im Augenblick nicht wichtig.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Pointer-Arithmetik ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kommen wir nun zu Pointer-Arithmetik, die wir vorhin
	bereits mehrfach verwendet haben.

	Mit Pointern kann man Rechnen, daher Arithmetik.

	Beim Array-Zugriff passiert das automatisch.
	Aber was passiert da eigentlich genau?
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Pointer-Arithmetik ====
{\Large
    {\ttfamily
        int numbers[3];\\
        char text[] = ``software libre'';\\
    }
~\\
    \uncover<2->{Es gilt:\\
    {\ttfamily
        \ind{}1.~numbers[i]~\,\textsf{=}\,~*(numbers + i)\\
        \ind{}2.~\uncover<3->{text[j]~\,\textsf{=}\,~*(text + j)\\}
        \ind{}3.~\uncover<4->{sizeof(char)~\,$\neq$\,~sizeof(int)\\}
    }
~\\
    \uncover<5->{Für Operatoren +/- auf Pointern folgt:\\}
    \uncover<6->{\ind{}Sprungweite variiert mit dem Typen!\\}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Angenommen wir haben zwei Arrays: numbers und text.
	Eins von denen ist ein String, aber das stört nicht weiter.

	Ein paar Dinge müssen dann gelten:
	1.	Der Array-Zugriff auf Array "numbers" gehorcht dieser Formel;
		das hatte ich ja vorhin eingeführt.
	2.	Auch der Array-Zugriff auf Array "text" gehorcht dieser
		Formel.
	3.	char und int sind auf den meisten Maschinen nicht gleich groß.

	Gibt es da nicht ein Problem - kann das funktionieren?
	Ich geb die Frage mal an euch weiter: kann das funktionieren?

	<PAUSE>

	Für die Operatoren "+" und "-" auf Pointern folgt:
	Die Sprungweite variiert mit dem Typen.
	Auf einer 32-Bit-machine liegt "numbers + 1" springt
	4 Byte wegen sizeof(int) gleich 4, aber "text + 1" springt
	nur 1 Byte weiter wegen sizeof(char) gleich 1.

	Das ist der Grund, warum int * und char * nicht das gleiche sind.
	Diese Information braucht der Compiler für die Pointer-Arithmetik.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Strings ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kommen wir nun zu ganz speziellen Arrays, zu Strings.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Längencodierung}
\enableintroslides{}


==== Längencodierung ====
{\Large
Pascal Strings\\
\ind{}{\ttfamily``ABC''~\sexyarrowrightLarge{}~\{\;\highlight{3}, 65, 66, 67\;\}}\\
~\\
\uncover<2->{C Strings\\[0.55ex]%workaround
\ind{}{\ttfamily``ABC''~\sexyarrowrightLarge{}~\{\;65, 66, 67, \highlight{0}\;\}}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TODO
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Strings ====
{\ttfamily\LARGE
    ``ABC''\phantom{$\backslash$0}\uncover<2->{~\sexyarrowrightLARGE{}~\{\;65, 66, 67, 0\;\}\\
    \uncover<3->{``012''\phantom{$\backslash$0}\uncover<4->{~\sexyarrowrightLARGE{}~\{\;48, 49, 50, 0\;\}\\}}
    \uncover<5->{``012$\backslash$0''\uncover<6->{~\sexyarrowrightLARGE{}~\{\;48, 49, 50, 0, 0\;\}\\}}
~\\[1ex]
    \uncover<7->{{\ttfamily
        \#include <string.h>\\
        ...\\
        strlen(``ABC'');\\[1ex]
    }
    \uncover<8->{\textsf{=}\,~3\\}}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Wenn der Compiler diesen String "ABC" sieht, macht er daraus
	folgendes Array: 65, 66, 67, 0.

	Die Null markiert das Ende.  Irgendwie müssen wir codieren,
	wie lang ein String ist.  Die Länge in einem Integer mitzuführen
	hätte auch funktioniert, aber diese Variante benötigt weniger
	Speicher.  Jedenfalls haben sich die Erfinder von C entschieden,
	Strings nullzuterminieren und so ihre Länge zu codieren.

	Dass die Null das Ende des Strings markiert heißt aber nicht,
	dass wir die zahl Null nicht in einen String schreiben dürfen:

	Dieser String - "012" - wird ersetzt durch 48, 49, 50, 0.
	Der Ascii-Wert des Zeichens "0" ist 48.

	Künstlich den Wert Null einfügen können wir auch:
	Aus 0, 1, 2, Backslash 0 wird 48, 49, 50, 0 und nochmal 0.

	Die Länge eines Strings müssen wir nicht per Hand berechnen.
	Das macht die Funktion "strlen" aus string.h für uns.

	strlen von "ABC" liefert den Wert 3.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{\texttt{my\_strlen}}
\enableintroslides{}


==== my\_strlen ====
{\ttfamily\LARGE
    int my\_strlen(const char * str) \{\\
    \uncover<2->{~~char const * const begin = str;\\}
    \uncover<3->{~~while (*str) \{\\
    ~~~~str++;\\
    ~~\}\\}
    ~~return (\uncover<4->{\highlight{str - begin}});\\
    \}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Ich möchte nun mit euch unser eigenes strlen() programmieren.

	Ich habe unsere Funktion \texttt{my\_strlen} genannt.

	Sie arbeitet auf einem char-Pointer "str", zu dem const
	kommen wir später.

	Zunächst merken wir uns den Wert von str in einer eigenen
	Variable "begin".  Wir werden str verändern - quasi mit
	str über den String laufen - und würden diesen Wert sonst
	verlieren.

	Nun laufen wir in einer Schleife solange im String
	vorwärts, wie das aktuelle Zeichen nicht 0 ist, also
	nicht das Ende des Strings markiert.

	Nach dieser Schleife zeigt str also genau auf dem Terminator.

	Was müssen wir nun zurückgeben um die Länge des Strings zu
	erhalten?

	<PAUSE>

	Richtig, "str - begin".  Auch das ist wieder Pointer-Arithmetik.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== String API ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TODO
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Auszug}
\enableintroslides{}


==== String API (Auszug) ====
{\Large
Vergleich\\
\uncover<2->{\ind{}\texttt{strcmp}, \texttt{strncmp}\\}
Suche\\
\uncover<2->{\ind{}\texttt{strstr}, \texttt{strchr}\\}
Formatierung, Verkettung\\
\uncover<2->{\ind{}\texttt{snprintf}\\}
Auswertung, Analyse\\
\uncover<2->{\ind{}\texttt{strtol}, \texttt{sscanf}\\}
Helfer\\
\uncover<2->{\ind{}\texttt{strdup}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TODO
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>


\disableintroslides{}
\subsection{Manpages}
\enableintroslides{}

==== Manpages ====
{\Huge\ttfamily
\# \highlight{man string}\\
\# man string.h\\
\# man stdio.h\\
\# man stdlib.h\\
~
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TODO
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


\disableintroslides{}
\subsection{Problemfälle}
\enableintroslides{}

==== Bitte vermeiden: ====
{\Huge
\begin{itemize}
\item \texttt{atoi}, \texttt{atol}, \texttt{atoll}, \texttt{atoq}
\item \texttt{gets}
\item[($\cdot$\hspace*{-0.125ex}] \texttt{scanf}, \texttt{fscanf}, \ldots{})
\item \texttt{sprintf}, \texttt{vsprintf}
\item \texttt{strcat}, \texttt{strncat}
\item \texttt{strcpy}, \texttt{strncpy}
\end{itemize}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TODO
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== ====
{\LARGE
* \texttt{gets}
* \texttt{scanf}, \texttt{fscanf}, \texttt{sscanf}, \texttt{vscanf}, \ldots{}
* \texttt{sprintf}, \texttt{vsprintf}
* \texttt{strcat}
* \texttt{strcpy}
~\\[1ex]
Buffer-Overflows\\[1ex]
Besser:\quad{}\texttt{s\underline{n}printf}, \texttt{vs\underline{n}printf}, \texttt{\underline{f}gets}\\
~
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TODO
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Beispiel \texttt{scanf} ====
{\Large{\ttfamily
\#include <stdio.h>\\
~\\
void main() \{\\
\ind{}char text[3];\\
\ind{}scanf(``\%s'', text);\\
\}\\
~\\}
\uncover<2->{Buffer-Overflow für\\
\ind{}$\texttt{strlen(\emph{input})} \,\ge\, 3$\\
~\\
{\ttfamily
\uncover<3->{\# echo 123456789012345678901234 | ./crash\\
Segmentation fault}
}}}


==== Beispiel \texttt{sprintf} ====
{\Large{\ttfamily
void log\_error(const char * error) \{\\
\ind{}char text[256];\\
\ind{}sprintf(text, ``ERROR: \%s'', error);\\
\ind{}log\_message(text);\\
\}}\\
\uncover<2->{~\\
Buffer-Overflow für\\
\ind{}$\texttt{strlen(error)} \,>\, 256 - 7 - 1 = 248$\\
~\\
\uncover<3->{(Halbherzige) Abhilfe:\\
\ind{}\texttt{s\highlight{\underline{n}}printf(text, \highlight{sizeof(text)}, .....);}\\
~
}}}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TODO
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== ====
{\LARGE
* \texttt{strncpy}
~\\[12ex]
Nullterminator nicht garantiert\\[1ex]
Besser:\quad{}\texttt{snprintf}\\
~
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TODO
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Beispiel \texttt{strncpy} ====
{\Large{\ttfamily
char text[5];\\
~\\
strncpy(text, ``Test'', sizeof(text));}\\
\uncover<2->{\ind{}\sexyarrowrightLarge~\,schreibt~\,\{\;84, 101, 115, 116, \highlight{0}\;\}\\
~\\
\uncover<3->{\texttt{strncpy(text, ``Hallo'', sizeof(text));}\\
\uncover<4->{\ind{}\sexyarrowrightLarge~\,schreibt~\,\{\;72, 97, 108, 108, \highlight{111}\;\}\\
\ind{}\sexyarrowrightLarge~\,nicht nullterminiert\\
~\\
\uncover<5->{\texttt{s\underline{n}printf(text, sizeof(text), ``\%s'',\\
\hfill{}``Hallo'');}\\
\uncover<6->{\ind{}\sexyarrowrightLarge~\,schreibt~\,\{\;72, 97, 108, 108, \highlight{0}\;\}\\
~
}}}}}}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TODO
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== ====
{\LARGE
* \texttt{atoi}
* \texttt{atol}
* \texttt{atoll}
* \texttt{atoq}
~\\[3.8ex]
Fehlerbehandlung fehlt\\[1ex]
Besser:\quad{}\texttt{strtol}, \texttt{strtoll}\\
~
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TODO
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Beispiel \texttt{atoi} ====
{\LARGE
\texttt{atoi(``Hallo'')}\phantom{\texttt{0}}\sexyarrowrightLARGE~\,0\\[1ex]
\texttt{atoi(``0'')}\phantom{\texttt{Hallo}}\sexyarrowrightLARGE~\,0
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	TODO
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Const Correctness ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kommen wir nun zu Const Correctness, zu korrekter
	Verwendung des Modifikators "const".
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Einführung}
\enableintroslides{}


==== Const Correctness~~(1/6) ====
{\LARGE
<[center]
Modifikator \texttt{const}\\verbietet Schreibzugriff
[center]>
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Zu allererst sollte ich erwähnen was const eigentlich
	tut: const verbietet Schreibzugriff auf bestimmte Variablen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Const Correctness~~(2/6) ====
{\ttfamily\LARGE
~~\only<1,3->{\underline{~~~~~}}\only<2>{\underline{\highlight{const}}} int \only<-2>{\underline{~~~~~}}\only<3->{\underline{\highlight{const}}} foo;\\~\\\phantom{<2a>}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Bei dieser Deklaration des Integers foo wäre const
	an zwei Stellen erlaubt: links vom int und rechts vom int.

	Auf welcher Seite man es schreibt, ist hier Geschmacksache.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Const Correctness~~(3/6) ====
{\ttfamily\LARGE
~~\underline{~~~~~}~int~\underline{~~~~~}~*~\underline{~~~~~}~foo;\\
~~\uncover<3->{~~|~~~~~~~~~|~~~~~}\uncover<2->{~~|\\}
~~\uncover<3->{~<2a>~~~~~~<2b>~~~}\uncover<2->{~<1>\\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Bei einfachen Pointern kommt nun eine wietere Stelle hinzu,
	an der const stehen darf.

	Ich benenne diese Stellen mal eben mit "1", "2a" und "2b".
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Const Correctness~~(4/6) ====
{\ttfamily\LARGE
    <1>~~\underline{~~~~~}~int~\underline{~~~~~}~*~\underline{const}~foo;\\
    \uncover<2->{~~~~~~~\textsf{Verboten:}\\
    ~~~~~~~foo = \ldots{};\\
~\\
    \uncover<3->{<2a>~\underline{const}~int~\underline{~~~~~}~*~\underline{~~~~~}~foo;\\
    <2b>~\underline{~~~~~}~int~\underline{const}~*~\underline{~~~~~}~foo;\\
    \uncover<4->{~~~~~~~\textsf{Verboten:}\\
    ~~~~~~~foo[0] = \ldots{};\\}}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Steht const an Position 1 - also ganz rechts beim foo -
	darf der Wert von foo selbst nicht mehr verändert werden.

	Steht const hingegen beim int so darf der Inhalt hinter foo
	nicht geschrieben werden.

	Diese beiden Fälle lassen sich auch kombinieren ...
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Const Correctness~~(5/6) ====
{\ttfamily\LARGE
    <2a,1>~\underline{const}~int~\underline{~~~~~}~*~\underline{const}~foo;\\
    <2b,1>~\underline{~~~~~}~int~\underline{const}~*~\underline{const}~foo;\\
    \uncover<2->{~~~~~~~\textsf{Verboten:}\\
    ~~~~~~~~~~foo~= \ldots{};\\
    ~~~~~~~foo[0]~= \ldots{};}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Steht beim int und bei foo const, so darf weder foo selbst
	noch der Inhalt hinter foo verändert werden.

	Schauen wir uns noch ein Beispiel mit Doppelpointern an ...
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Const Correctness~~(6/6) ====
{\ttfamily\LARGE
    ~~~~const int * const * foo;\\
    \uncover<2->{~~~~~~~\textsf{Erlaubt:}\\
    ~~~~~~~~~~~~~foo~= \ldots{};\\}
    \uncover<3->{~~~~~~~\textsf{Verboten:}\\
    ~~~~~~~~~~foo[0]~= \ldots{};\\
    ~~~~~~~foo[0][0]~= \ldots{};\\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Was darf ich mit dieser Variable machen?

	<PAUSE>

	Richtig, ich darf foo selbst verändern.

	Was ich nicht verändern darf, ist der Inhalt hinter foo und
	der Inhalt hinter dem Inhalt von foo.

	Gibt es Fragen dazu?

	<PAUSE>

	Ich schulde euch noch eine Erklärung zu unserer Funktionen
	\texttt{my\_strlen} von vorhin ...
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Fall \texttt{my\_strlen}}
\enableintroslides{}


==== Const Correctness in APIs ====
{\Large
    \texttt{int my\_strlen(\phantom{const}~char * str);\\}
    \uncover<2->{\ind{}Funktion darf \emph{Inhalt} von \texttt{str} verändern\\}
    \uncover<3->{\ind{}\texttt{my\_strlen(``ABC'')} gibt Compile-Fehler\\}
~\\
    \texttt{int my\_strlen(\underline{const}~char * str);\\}
    \uncover<4->{\ind{}Funktion darf Inhalt von \texttt{str} \emph{nicht} verändern\\}
    \uncover<5->{\ind{}\texttt{my\_strlen(``ABC'')} erlaubt und sicher\\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Hier seht ihr zwei verschiedene Prototypen von texttt{my\_strlen}:
	einen mit const und einen ohne.  Wo liegt der Unterschied?

	Aus Sicht des Compilers darf die Variante ohne const den
	Inhalt von str verändern.  Wenn wir diese Funktion mit der
	String-Konstante "ABC" aufrufen, wirft der Compiler einen Fehler.

	Der Typ von String-Konstanten ist "const char *".
	Diese Variante von \texttt{my\_strlen} erwartet zuviel vom übergegen String:
	sie erwartet, schreiben zu dürfen.

	Bei der Variante mit const darf die Funktion den Inhalt von
	str nicht ändern.  Ein Aufruf mit der String-Konstante "ABC"
	ist daher erlaubt und sicher.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Initialisierung von Strings ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kommen wir nun zur Initialisierung von Strings.

	In C ist das auf zwei sehr verschiedene Arten möglich.
	Sehen wir uns das näher an ...
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Varianten}
\enableintroslides{}

==== Initialisierung von Strings ====
{\Large
    \uncover<3->{Variante \glqq{}Mit Array\grqq{}\\}
    \ind{}\texttt{char a[] = ``Hallo'';}\\
    \uncover<2->{\ind{}\texttt{sizeof(a) = sizeof(char)*(5 + 1)}\\}
    \uncover<4->{\ind{}Inhalt les- und schreibbar\\}
~\\
    \uncover<5->{Variante \glqq{}Nur Pointer\grqq{}\\}
    \uncover<6->{\ind{}\texttt{\only<9->{\highlight{const} }char * p = ``Hallo'';}\\}  % gcc -Wwrite-strings
    \uncover<7->{\ind{}\texttt{sizeof(p) = sizeof(char *)}\\}
    \uncover<8->{\ind{}Inhalt \emph{nicht} schreibbar\\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Hier initialisieren wir einen String a mit "Hallo".
	im Speicher belegt a dann 5 + 1 Byte, 5 Byte für jeden
	Buchstaben, 1 Byte extra für den Nullterminator.

	Diese Variante möchte ich "Mit Array" nennen.
	a ist ein vollwertiges Array, sein Inhalt ist les- und schreibbar.

	Die Zweite Variante nenne ich "Nur Pointer".
	Ihre Syntax ist anders: syntaktisch deklarieren wir hier einen
	ganz normalen Pointer.  Und das ist p auch im Hinblick auf
	seine Größe: ein ganz normal Pointer: auf einer 32-Bit-Machine
	4 Byte groß.  Sein inhalt ist \emph{nicht} schreibbar.

	Weil sein Inhalt nicht schreibbar ist, fehlt von der
	Const Correctness her bei dieser Variante auch ein const.

	Schauen wir uns dazu noch einmal etwas Code an ...
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Beispielcode}
\enableintroslides{}


==== Variante \glqq{}Nur Pointer\grqq{} ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
int main() \{\\
~~char * a = ``hallo'';\\
~~char * b = ``hallo'';\\
~\\
~~\uncover<2->{printf(``a=\%p$\backslash$n''\\
~~~~~~~~~``b=\%p$\backslash$n'', a, b);\\
~\\
~~\uncover<3->{a[0] = `X';\\}}
~\\
~~return 0;\\
\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Hier definieren wir zwei Strings in der Variante "Nur Pointer",
	beide mit dem Text "hallo".

	Dann geben wir ihre Adressen aus.
	Zur Erinnerung: "\%p" im Format-String steht für Pointer.
	Für ihren Inhalt hätten wir "\%s" geschrieben.

	Danach überschreiben wir den ersten Buchstaben von a mit
	einem großen "X".  Schauen wir uns an, was passiert ...
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Ausgabe}
\enableintroslides{}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,rombad.c~\,-o rombad\\
    \uncover<2->{\# ./rombad\\
    \uncover<3->{a=\only<3,5->{0x80484dc}\only<4>{0x\highlight{80484dc}}\\
    b=\only<3,5->{0x80484dc}\only<4>{0x\highlight{80484dc}}\\
    \uncover<5->{Segmentation fault}}}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kompilieren, ausführen, ... da sind a und b.

	Wie ihr seht - sie haben dieselbe Adresse!

	a und b zeigen also auf den gleichen Speicherbereich.
	Wenn wir nun den Text hinter a verändern, ändert sich auch b.

	Aber dazu kommt es nicht: Es knallt - wir bekommen einen
	Segmentation Fault.

	Dieser Speicher ist nicht schreibbar, ich sagte es ja bereits.

	Warum warnt uns der Compiler nicht?
	Wir hatten ihn bisher nicht darum gebeten.
	Tun wir das doch mal...
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Compiler-Warnungen}
\enableintroslides{}


==== GCC Flag \texttt{-Wwrite-strings} ====
{\ttfamily\large
    \# gcc~\,-Wall -Wextra \highlight{-Wwrite-strings} $\backslash$\\
    ~~~~~~rombad.c~\,-o rombad\\
    \uncover<2->{rombad.c: In function `main':\\
    rombad.c:4: warning: initialization discards\\
    ~~~~qualifiers from pointer target type\\
    rombad.c:5: warning: initialization discards\\
    ~~~~qualifiers from pointer target type}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Compilieren wir also noch einmal.
	-Wall und -Wextra möchte ich generell empfehlen,
	für dieses Beispiel wird aber noch -Wwrite-strings benötigt.
	Ja, wirklich.

	Und da sind die Warnungen, die wir erwarten können.
	"discards qualifiers" bedeutet: Da fehlt const.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Variante \glqq{}Nur Pointer\grqq{} ====
{\ttfamily\large
\#include <stdio.h>\\
~\\
int main() \{\\
~~\only<2>{\highlight{const~}}\only<3->{const~}char * a = ``hallo'';\\
~~\only<2>{\highlight{const~}}\only<3->{const~}char * b = ``hallo'';\\
~\\
~~printf(``a=\%p$\backslash$n''\\
~~~~~~~~~``b=\%p$\backslash$n'', a, b);\\
~\\
~~\only<3>{\highlight{a[0] = `X';}}\only<-2>{a[0] = `X';}\\
~\\
~~return 0;\\
\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	So sah unser Code eben aus.

	Hier gehört eigentlich const hin.

	Wenn wir dieses const einfügen, merkt der Compiler
	hier unten, dass wir böse Dinge tun, und verbietet uns das.

	Damit wissen sie jetzt ausgezeichnet Bescheid über die
	Initialisierung von Strings.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Mehrdimensionale Arrays ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Für die Repräsentation von mehrdimensionalen Arrays
	gibt es in C zwei Varianten, die sich stark unterscheiden.

	Wenn man über diesen Unterschied stolpert, steht man relativ
	im Dunklen: Zu diesem Thema schweigen tielweise auch dickere
	C-Bücher.  Im Internet dazu etwas zu finden, ist auch nicht
	einfach.

	Nicht zuletzt auch, weil ich dieses Thema spannend finde,
	möchte ich daher kurz auf diese zwei Repräsentationen eingehen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Überblick}
\enableintroslides{}


==== Mehrdimensionale Arrays ====
{\LARGE
Zwei Varianten:
* Array von Arrays (\glqq{}deep array\grqq{})
* linear (\glqq{}flat array\grqq{})
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Mehrdimensionale Arrays sind im Speicher entweder
	ein Array von Arrays (deep arrays) oder linear -
	quasi ein-dimensional - (flat arrays).
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

[frame]>


{
\disableintroslides{}
% Subsection mag keine Linebreaks...
\subsection{Variante \glqq{}Array von Arrays\grqq{}}
\introslide{Variante\\\glqq{}Array von Arrays\grqq{}}
\enableintroslides{}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Schauen wir uns zuerst die Variante "Array von Arrays" an.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== 2D-Array als Array von Arrays ====
<[center]
\only<1>{
<<<graphics/array-deep-minus-4,height=0.7\textheight>>>
}\only<2>{
<<<graphics/array-deep-minus-3,height=0.7\textheight>>>
}\only<3>{
<<<graphics/array-deep-minus-2,height=0.7\textheight>>>
}\only<4>{
<<<graphics/array-deep-minus-1,height=0.7\textheight>>>
}\only<5>{
<<<graphics/array-deep-minus-0,height=0.7\textheight>>>
}
[center]>
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Speichern wollen wir eine 2x3 Matrix, also ein Array
	mit 2 Zeilen und 3 Spalten.

	Bei dieser Variante liegen beide Zeilen als je ein 1D-Array
	im Speicher.

	Oben drauf setzen wir dann ein 1D-Array aus Pointern,
	die auf die Zeilen zeigen.  Dieses Zeilen-Pointer-Array
	ist das eigentliche Array, hier a genannt.

	a[0] zeigt auf die erste Zeile, a[1] auf die zweite.

	Hier unten sitzt a[1][2].

	Im Code sieht das dann so aus:
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== 2D-Array als Array von Arrays ====
{\ttfamily\Large
    \uncover<4->{void demo\_deep(\highlight{int *} const \highlight{* a}) \{\\
    ~~a[1][2] *= 2;\\
    \}\\}
~\\
    int main() \{\\
    \uncover<2->{~~int row0[] = \{0, 1, 2\};\\
    ~~int row1[] = \{3, 4, 5\};\\
    ~~int * const d[] = \{row0, row1\};\\
    \uncover<3->{~~demo\_deep(d);\\}}
    ~~return 0;\\
    \}\\
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Wieder das Gerüst, dann definieren wir die zwei Zeilen
	und dann das Zeilen-Pointer-Array.

	Dieses Array d kann ich dann an eine Funktion \texttt{demo\_deep}
	übergeben.

	Diese Funktion tut nicht viel Sinnvolles:
	sie verändert einfach einen der Einträge unserer Matrix.

	Das const habe ich eingefügt, weil \texttt{demo\_deep} sonst erlaubt
	wäre, die Struktur der matrix zu verändern, zum Beispiel
	Zeilen der Matrix zu vertauschen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


=== Variante \glqq{}Linear\grqq{} ===
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Die Variante "linear" sieht im Speicher völlig anders aus:
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== 2D-Array linear ====
<[center]
\only<1>{
<<<graphics/array-flat-minus-3,height=0.7\textheight>>>
}\only<2>{
<<<graphics/array-flat-minus-2,height=0.7\textheight>>>
}\only<3>{
<<<graphics/array-flat-minus-0,height=0.7\textheight>>>
}
[center]>
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	... Beide Zeilen liegen an einem Stück hintereinander
	im Speicher.

	a zeigt auf das erste Element.
	Die Ausdrücke "a[0]", "a[1]", "a[1][2]" funktionieren wie
	erwartet, dereferenzieren aber nicht wie erwartet.

	a ist kein Doppelpointer.  Wäre er das, müsste bei a im
	Speicher ein Pointer liegen.  Dort liegt aber ein Datum
	unseren Matrix.

	Wie sieht das im Code aus?
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== 2D-Array linear ====
{\ttfamily\Large
    \uncover<4->{void demo\_flat(\highlight{int a[][3]}) \{\\
    ~~a[1][2] *= 2;\\
    \}\\}
~\\
    int main() \{\\
    \uncover<2->{~~int f[][3] = \{ \{0, 1, 2\},\\
    ~~~~~~~~~~~~~~~~~\{3, 4, 5\} \};\\
    \uncover<3->{~~demo\_flat(f);\\}}
    ~~return 0;\\
    \}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Wir initialisieren die Matrix in einem Stück ...
	und übergeben sie dann dan \texttt{demo\_flat}.

	Auffällig ist der Paramater a dieser Funktion:
	das ist kein Doppelpointer.  Und die 3 ist nötig,
	damit der Code kompiliert.  Der Kompiler weiß sonst nicht,
	wieviele Elemente er für eine Zeile überspringen muss.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


=== Variante \glqq{}Hybrid\grqq{} ===
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Eine dritte "hybride" Variante ergibt sich, wenn man beide
	Varianten kombiniert.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== 2D-Array-Hybrid ====
{\ttfamily\Large
    \uncover<5->{void demo\_deep(\highlight{int *} const \highlight{* a});\\
    void demo\_flat(\highlight{int a[][3]});\\}
~\\
    int main() \{\\
    \uncover<2->{~~int f[][3] = \{ \{0, 1, 2\},\\
    ~~~~~~~~~~~~~~~~~\{3, 4, 5\} \};\\
    \uncover<3->{~~int * const d[] = \{f[0], f[1]\};\\
    \uncover<4->{~~demo\_deep(d);\\
    ~~demo\_flat(f);\\}}}
    ~~return 0;\\
    \}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Wir initialisieren f als Flat Array wie zuvor.

	Oben drauf setzen wir dann ein Zeilen-Pointer-Array,
	das in f Zeigt.  Die Ausdrücke f[0] und f[1] liefern,
	was wir dazu brauchen.

	Das resultierende Array d ist mit unserer früheren
	Funktion \texttt{demo\_deep} kompatibel, während f selbst weiterhin
	\texttt{demo\_flat} bedienen kann.

	Zur Erinnerung: So sahen die Prototypen aus.

	Fragen hierzu würde ich aus Zeitgründen gern erst am Ende
	des Vortrags oder nach dem Vortrag klären.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== \texttt{argc} und \texttt{argv} ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Zu guter Letzt möchte ich vorstellen, wie man auf
	Programmargumente zugreifen kann, die beim Aufruf
	übergeben wurden.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\disableintroslides{}
\subsection{Beispielcode}
\enableintroslides{}


==== \texttt{argc} und \texttt{argv} ====
{\ttfamily\Large
    \#include <stdio.h>\\
~\\
    int main(\only<2->{int argc, char ** argv}) \{\\
    \uncover<4->{~~int i = 0;\\}
    \uncover<3->{~~printf(``\%d parameters$\backslash$n'', argc - 1);\\}
    \uncover<4->{~~for (; i < argc; ++i) \{\\
    \uncover<5->{~~~~printf(``[\%d] \%s$\backslash$n'', i, argv[i]);\\}
    ~~\}\\}
    ~~return 0;\\
    \}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Das ist die main()-Funktion, wie ihr sie inzwischen
	Dutzende Male gesehen habt.

	Das hier ist eine Alternative, die Zugriff auf Programmargumente
	erlaubt.

	Für die, die wissen, was Overloading ist:
	Mit Overloading hat das nichts zu tun - C unterstützt kein Overloading.

	argc ist die Anzahl der Parameter, die wir übergeben bekommen:
	es ist die Anzahl der Einträge in argv.

	Weil das erste Element unser Programmename ist, gibt es also
	argc - 1 echte Parameter.

	In einer Schleife laufen wir über das Array, dass ein echtes
	\glqq{}Deep Array\grqq{} aus Zeilen-Pointern ist.

	argv[i] ist vom Typ char *, was mit Nullterminierung Strings sind.
	Diese übergeben wir direkt an printf().
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[frame]>

\disableintroslides{}
\subsection{Ausgabe}
\enableintroslides{}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,print\_args.c~\,-o print\_args\\
    \uncover<2->{\# ./print\_args~free 'open source' software\\}
    \uncover<3->{3 parameters\\
    {}[0] ./print\_args\\
    {}[1] free\\
    {}[2] open source\\
    {}[3] software\\}
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Kompilieren, ausführen, ... 3 Parameter.

	Die Shell hat wegen der Anführungszeichen "open" und "source"
	als ein Element verstanden.

	Element 0 enthält den Namen des Programms, so wie es
	aufgerufen wurde.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Weiterführende Themen ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Weiterführende Themen: Ein paar Dinge habe ich absichtlich
	ausgelassen:
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

==== Weiterführende Themen ====
{\Large
* Character Encodings, Unicode, \texttt{wchar\_t}
* Sicherer Umgang mit Strings
* Der Typ \texttt{size\_t}
* Void-Pointer
* Funktions-Pointer
* Dynamische Speicherverwaltung
* Komplexe Datenstrukturen
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	... Wir haben uns nicht mit Character Encodings und Unicode
	beschäftigt.  Für uns war Text ASCII-enkodiert.
	Das ist nicht immer so.

	Die dynamische Längenberechnung von Strings kann zu einem
	Sicherheits-Problem werden, wenn man nicht sorgfältig damit
	umgeht.  Aus das haben wir ausgeblendet.

	Der Rückgabetyp unserer Funktion \texttt{my\_strlen} hätte \texttt{size\_t}
	sein sollen, nicht int.  Was es damit auf sich hat,
	hat hier keinen Platz mehr gefunden.

	Auch Void- und Funktions-Pointer haben wir außen vorgelassen.
	Beides sind einfache Themen, die ihr euch schnell selbst
	aneignet.

	Auf dynamische  Speicherverwaltung wird später im Kurs noch
	detailliert eingegangen.  Mit ihrer Hilfe lassen sich erst
	wirklich komlexe Datenstrukturen erzeugen.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


== Zusammenfassung ==
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Wir haben aber auch viel geschafft.
	Wir haben Grundlagen aufgebaut und einige Stolpersteine
	umgedreht.

	Was ihr unbedingt mitnehmen müsst:
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== Zusammenfassung ====
{\Large
* \texttt{sizeof(\emph{x})} liefert die Größe von \texttt{\emph{x}} in Byte
* Operator \texttt{\&} liefert eine Adresse
* Operator \texttt{*} folgt einer Adresse\\\hfill{}(er \emph{dereferenziert})
* Pointer sind typisiert
* Arrays sind Pointer auf ihr erstes Element
* Strings sind nulltermininiert
* Const Correctness bei Pointern ist \emph{keine}\\\hfill{}Geschmacksfrage
}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	... sizeof(x) liefert die Größe von x in Byte.

	Der Operator \& liefert eine Adresse, der Operator * dagegen
	folgt einer Adresse.  Man sagt er dereferenziert.

	Pointer sind typisiert.  Wir haben gesehen, wie sich die
	Pointer-Arithmetik das zu nutze macht.

	Arrays sind auch Pointer auf ihr erstes Element.
	Ihr erinnert euch an die Formel von vorhin: a[n] = *(a + n).

	Strings sind nullterminiert, ihre Größe wird dynamisch
	berechnet.  Auch das haben wir uns genau angesehen.

	Const Correctness bei Pointern ist mehr als nur Geschmack
	sondern macht einen echten Unterschied.

	Wenn ihr das was auf dieser Folie steht wirklich verstanden
	habt, vielleicht sogar anderen erklären könnt, dann bin ich
	stolz darauf, euch das beigebracht zu haben.

	Eine letzte Bitte an euch: wenn ihr Code schreibt,
	veröffentlicht ihn als Freie Software.  Für Fragen
	zu diesem Thema bin ich immer haben.
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


==== ====
<[center]
{\Huge
Danke!\\
~\\
Fragen?\\
\vfill
\vfill
}
{\LARGE http://blog.hartwork.org/}
[center]>
\vspace*{-4ex}
\note{%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Damit bedanke ich mich für eure Aufmerksamkeit.

	Gibt es Fragen?
}%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
