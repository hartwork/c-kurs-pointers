% Copyright (C) 2009 Sebastian Pipping <sebastian@pipping.org>
% Licensed under Creative Commons Attribution-ShareAlike 3.0 License
%
\newcommand{\ind}{\hspace*{3ex}}
\setbeamertemplate{footline}{\vspace*{-2cm}\hfill\Large\insertpagenumber\vspace*{0.5ex}\hspace*{0.5ex}}
\newcommand{\highlight}[1]{{\color{yellow} #1}}
\newcommand{\exclamation}{!}
\newcommand{\comment}[1]{}
\newcommand{\introslide}[1]{
    {\setbeamertemplate{footline}{}
        \begin{frame}%<beamer>
            \frametitle{}
            \begin{center}\Huge
                #1
            \end{center}
        \end{frame}
    }
}
\AtBeginSection[] % Do nothing for \section*
{
    \introslide{\insertsection}
}
\AtBeginSubsection[] % Do nothing for \subsection*
{
    \introslide{\insertsubsection}
}


==== C-Kurs ====
{\Large
\hspace*{2ex}\phantom{Next --> }\hspace*{1ex}Konzepte, Syntax, ...\\
\hspace*{2ex}\phantom{Next --> }\hspace*{1ex}printf, scanf\\[1ex]
\hspace*{2ex}Next --> \hspace*{1ex}Pointers, Arrays, ...\\
\hspace*{2ex}\phantom{Next --> }\hspace*{1ex}Structs, malloc, ...\\[1ex]
\hspace*{2ex}\phantom{Next --> }\hspace*{1ex}Compiler, Headers, ...\\
\hspace*{2ex}\phantom{Next --> }\hspace*{1ex}Debugging I\\[1ex]
\hspace*{2ex}\phantom{Next --> }\hspace*{1ex}Guter Code\\
\hspace*{2ex}\phantom{Next --> }\hspace*{1ex}Debugging II\\[1ex]
\hspace*{2ex}\phantom{Next --> }\hspace*{1ex}stdlib, Bücher, ...\\
}


==== Übersicht ====
{\LARGE
* Pointers
* Arrays
* Strings
}

==== Übersicht ====
{\LARGE
Grundlagen für ..
* Multiplikation von Matrizen
* Speicherverwaltung\\\ind{}(nächste Vorlesung)
}


==== Themen ====
{\large
* Hello pointer
* Pointer auf Pointer
* Arrays und Pointer
* Pointer-Arithmetik
* Strings und Längenberechnung
* const correctness
* argc und argv
* Mehrdimensionale Arrays
* Deklaration von Strings
* NULL-Pointer\vspace*{1ex}
* Weiterführende Themen
* Zusammenfassung
}
%* Strings versus "Memory"


==== Organisatorisches ====
{\LARGE
Wir haben viel vor.\\
~\\
Eure Fragen...
* bitte notieren, mit Slidenummer
* beantworte ich gern am Ende
* Ausnahme: Verständnisfragen
}


== Pointer ==

==== Pointer ====
{\LARGE
* zeigen auf eine Stelle im Speicher

*<2-> sind Adressen
*<3-> sind Zahlen
*<4-> sind quasi auch Referenzen
}


== Hello pointer ==

==== Hello pointer ====
{\ttfamily\large
    \#include <stdio.h>\\
~\\
    int\\
    main() \{\\
    ~~int i = 3;\\
    \uncover<2->{~~int *p = \&i;\\}
~\\
    \uncover<3->{~~printf(" p == \%\#p$\backslash$n"\\
    ~~~~~~~~~"*p == \%d$\backslash$n"\\
    ~~~~~~~~~" i == \%d$\backslash$n", p, *p, i);\\}
~\\
    \uncover<4->{~~*p = 14;\\
    ~~printf(" i == \%d$\backslash$n$\backslash$n", i);\\}
    ~~return 0;\\
    \}
}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,hello\_pointer.c~\,-o hello\_pointer\\
    \uncover<2->{\# ./hello\_pointer\\
    \uncover<3->{~p == 0xbfa3ad8c\\
    *p == 3\\
    ~i == 3\\
    ~i == 14\\
~\\
    \uncover<4->{\# ./hello\_pointer\\
    ~p == 0xbfba66fc\uncover<5->{~\highlight{\textsf{ <-- Andere Adresse!}}}\\
    *p == 3\\
    ~i == 3\\
    ~i == 14}}}
}


==== Zusammenfassung 1/2 ====
{\LARGE
Pointer zeigen auf typisierte Daten:\\[1ex]
\ind{}\texttt{~int *} == Pointer auf int\\[1ex]
\ind{}\texttt{char *} == Pointer auf char
}

==== Zusammenfassung 2/2 ====
{\LARGE
*<1-> Prefix-Operator \& liefert Adresse
*<2-> Prefix-Operator * dereferenziert

*<3-> \& und * sind komplementär:\\\ind{}*(\&x) == x
}


== Pointer auf Pointer ==

==== Pointer auf Pointer ====
{\ttfamily\Huge
    int a = 3;\\
    int *pa = \&a;\\[1ex]
    \uncover<2->{int **ppa = \&pa;}
}


==== Wohin mit den Sternen?~~(1/2) ====
{\ttfamily\Huge
    \only<1-2>{int**~~foo;}\only<3->{\xout{int**~~foo;}}\uncover<2>{~\highlight{\textsf{ <-- Bitte nicht!}}\\}
    int~**~foo;\\
    int~~**foo;\\
}

==== Wohin mit den Sternen?~~(2/2) ====
{\ttfamily\LARGE
    int x, y, z;\\
~\\
    \uncover<2->{int** a, b;\uncover<3->{~~/* Misleading */\\
    \uncover<4->{int **a, b;\uncover<5->{~~/* Better */\\
~\\
    \uncover<6->{/* Best:~*/\\
    int **a;\\
    int b;\\}}}}}
}


== Arrays und Pointer ==

==== Arrays und Pointer~~(1/3) ====
{\ttfamily
    \#include <stdio.h>\\
~\\
    int\\
    main() \{\\
    ~~int primes[] = \{2, 3, 5, 7, 11\};\\
    ~~int i;\\
~\\
    \uncover<2->{~~for (i = 0; i < 5; ++i) \{\\
    \uncover<3->{~~~~printf("primes[\%d] == \%d$\backslash$n", i,\\
    ~~~~~~~~primes[i]);\\}
    ~~\}\\}
    ~~return 0;\\
    \}
}


==== Zusammenfassung ====
{\LARGE
<[center]
Zugriff via [\emph{n}] ähnlich Java
[center]>
}


==== Arrays und Pointer~~(2/3) ====
{\ttfamily
    \#include <stdio.h>\\
~\\
    int\\
    main() \{\\
    ~~int primes[] = \{2, 3, 5, 7, 11\};\\
    ~~int i;\\
~\\
    ~~for (i = 0; i < \only<1>{5}\only<2->{\highlight{sizeof(primes) / sizeof(int)}}; ++i) \{\\
    ~~~~printf("primes[\%d] == \%d$\backslash$n", i,\\
    ~~~~~~~~primes[i]);\\
    ~~\}\\
    ~~return 0;\\
    \}
}


==== Zusammenfassung~~(1/2) ====
{\Large
<[center]
\texttt{sizeof(\emph{variable})\\==}\\
Von \texttt{\emph{variable}} belegter Speicher in Byte
[center]>
}


==== Zusammenfassung~~(2/2) ====
{\Large
<[center]
\texttt{sizeof(\highlight{\emph{type}})\\==}\\
Von \highlight{\texttt{\emph{type}}-Instanzen} belegter Speicher in Byte
[center]>
}


==== Arrays und Pointer~~(3/3) ====
{\ttfamily
    \#include <stdio.h>\\
~\\
    int\\
    main() \{\\
    ~~int primes[] = \{2, 3, 5, 7, 11\};\\
    ~~int i;\\
~\\
    ~~for (i = 0; i < sizeof(primes) / sizeof(int); ++i) \{\\
    ~~~~printf("primes[\%d]\only<3->{ via array~~} == \%d$\backslash$n", i,\\
    ~~~~~~~~\only<1-4>{primes[i]}\only<5->{\highlight{{primes[i]}}});\\
    \only<2->{\uncover<4->{~~~~printf("primes[\%d] via pointer == \%d$\backslash$n", i,\\
    ~~~~~~~~\only<4>{*(primes + i)}\only<5->{\highlight{*(primes + i)}});\\}}
    ~~\}\\
    ~~return 0;\\
    \}
}


==== Zusammenfassung~~(1/2) ====
{\LARGE
<[center]
Array~\,\texttt{==}\,~Pointer auf den Anfang des Arrays
[center]>
}

==== Zusammenfassung~~(2/2) ====
{\ttfamily\Huge
<[center]
\emph{a}[\emph{n}]~==~*(\emph{a} + \emph{n})
[center]>
}


== Pointer-Arithmetik ==

==== Pointer-Arithmetik ====
{\Large
    {\ttfamily
        int numbers[3];\\
        char text[] = "software libre";\\
    }
~\\
    \uncover<2->{Es gilt:\\
    {\ttfamily
        \ind{}numbers[i] == *(numbers + i)\\
        \uncover<3->{\ind{}text[j] == *(text + j)\\}
        \uncover<4->{\ind{}sizeof(char) != sizeof(int)\\}
    }
~\\
    \uncover<5->{Für Operatoren +/- auf Pointern folgt:\\}
    \uncover<6->{\ind{}Sprungweite variiert mit dem Typen!\\}}
}


== Strings ==

==== Strings ====
{\LARGE
    "ABC"\uncover<2->{~ --> ~\{\,65, 66, 67, \underline{00}\,\}\\
~\\[1ex]
    \uncover<3->{{\ttfamily
        \#include <string.h>\\
        ...\\
        strlen("ABC");\\[1ex]
    }
    \uncover<4->{ --> 3\\}}}
}

==== my\_strlen ====
{\ttfamily\LARGE
    unsigned int\\
    my\_strlen(const char *str) \{\\
    \uncover<2->{~~const char *walker = str;\\}
    \uncover<3->{~~while (\only<3,6->{'$\backslash$0' \exclamation{}= *walker}\only<4>{\highlight{*walker}}\only<5>{\highlight{'$\backslash$0' \exclamation{}= }*walker}) \{\\
    ~~~~walker++;\\
    ~~\}\\}
    ~~return \uncover<6->{\highlight{walker - str}};\\
    \}
}


==== Strings ====
{\ttfamily\LARGE
    strlen("ABC");\\
    \uncover<2->{ --> 3\\[1ex]}
    \uncover<3->{strlen("A$\backslash$0B$\backslash$0C");\\}
    \uncover<4->{ --> 1\\[1ex]}
    \uncover<5->{strlen("ABC$\backslash$0$\backslash$0");\\}
    \uncover<6->{ --> 3\\}
}


== const correctness ==

==== const correctness~~(1/5) ====
{\LARGE
<[center]
\only<1>{const}\only<2>{\highlight{const}} char * \only<1>{const}\only<2>{\highlight{const}} foo = "foo";
[center]>
}

==== const correctness~~(2/5) ====
{\ttfamily\LARGE
~~\underline{~~~~~}~char~\only<3->{\underline{~~~~~}~*~\underline{~~~~~}~}foo;\\
~~\only<3->{\uncover<4->{~~|~~~~~~~~~~|~~~~~}}\uncover<2->{~~|\\}
~~\only<3->{\uncover<4->{~<2a>~~~~~~~<2b>~~~}}\uncover<2->{~<1>\\}
}

==== const correctness~~(3/5) ====
{\ttfamily\LARGE
    <1>~~char * const foo;\\
    \uncover<2->{~~~~~~~\textsf{Verbietet:}\\
    ~~~~~~~foo = bar;\\
~\\
    \uncover<3->{<2a> const char *foo;\\
    <2b> char const *foo;\\
    \uncover<4->{~~~~~~~\textsf{Verbietet:}\\
    ~~~~~~~foo[3] = ...;\\}}}
}

==== const correctness~~(4/5) ====
{\ttfamily\LARGE
    <2a,1> const char * const foo;\\
    \uncover<2->{~~~~~~~\textsf{Verbietet:}\\
    ~~~~~~~foo[3] = ...;\\
    ~~~~~~~foo = bar;\\
~\\
\uncover<3->{\highlight{\textsf{String-Konstanten bitte immer so $\uparrow$}}\\}}
}

==== const correctness~~(5/5) ====
{\ttfamily\LARGE
    char const * const * const foo;\\
    \uncover<2->{~~~~~~~\textsf{Verbietet:}\\
    ~~~~~~~foo = ...;\\
    ~~~~~~~foo[3] = ...;\\
    ~~~~~~~foo[7][2] = ...;\\}
}


==== const correctness in APIs ====
{\large
    \texttt{int my\_strlen(char *str);\\}
    \uncover<2->{\ind{}Funktion darf den \emph{Inhalt} von \texttt{str} verändern\\}
    \uncover<3->{\ind{}my\_strlen("ABC") gibt Compile-Fehler\\}
~\\
    \texttt{int my\_strlen(\underline{const} char *str);\\}
    \uncover<4->{\ind{}Funktion darf den Inhalt von \texttt{str} nicht verändern\\}
    \uncover<5->{\ind{}my\_strlen("ABC") erlaubt und sicher\\}
}


== argc und argv ==

==== argc und argv ====
{\ttfamily\Large
    \#include <stdio.h>\\
~\\
    int\\
    main(\only<2->{int argc, char **argv}) \{\\
    \uncover<4->{~~int i = 0;\\}
    \uncover<3->{~~printf("\%d parameters$\backslash$n", argc - 1);\\}
    \uncover<4->{~~for (; i < argc; ++i) \{\\
    \uncover<5->{~~~~printf("[\%d] \%s$\backslash$n", i, argv[i]);\\}
    ~~\}\\}
    ~~return 0;\\
    \}
}


==== Ausgabe ====
{\ttfamily\Large
    \# gcc~\,print\_args.c~\,-o print\_args\\
    \uncover<2->{\# ./print\_args~free 'open source' software\\}
    \uncover<3->{3 parameters\\
    {}[0] ./print\_args\\
    {}[1] free\\
    {}[2] open source\\
    {}[3] software\\}
}


== Mehrdimensionale Arrays ==
{
\subsection*{Variante "Array von Pointern"}
\introslide{Variante\\"Array von Pointern"}
}

==== 2D-Array als Array von Pointern ====
<[center]
\only<1>{
<<<graphics/array-deep-minus-4,height=0.7\textheight>>>
}\only<2>{
<<<graphics/array-deep-minus-3,height=0.7\textheight>>>
}\only<3>{
<<<graphics/array-deep-minus-2,height=0.7\textheight>>>
}\only<4>{
<<<graphics/array-deep-minus-1,height=0.7\textheight>>>
}\only<5>{
<<<graphics/array-deep-minus-0,height=0.7\textheight>>>
}
[center]>

==== 2D-Array als Array von Pointern ====
{\ttfamily\Large
    \uncover<4->{void demo\_deep(\highlight{int *} const \highlight{*a}) \{\\
    ~~a[1][2] *= 2;\\
    \}\\}
~\\
    int main() \{\\
    \uncover<2->{~~int row0[] = \{0, 1, 2\};\\
    ~~int row1[] = \{3, 4, 5\};\\
    ~~int * const d[] = \{row0, row1\};\\
    \uncover<3->{~~demo\_deep(d);\\}}
    ~~return 0;\\
    \}\\
}

=== Variante "Linear" ===

==== 2D-Array linear ====
<[center]
\only<1>{
<<<graphics/array-flat-minus-3,height=0.7\textheight>>>
}\only<2>{
<<<graphics/array-flat-minus-2,height=0.7\textheight>>>
}\only<3>{
<<<graphics/array-flat-minus-1,height=0.7\textheight>>>
}\only<4>{
<<<graphics/array-flat-minus-0,height=0.7\textheight>>>
}
[center]>

==== 2D-Array linear ====
{\ttfamily\Large
    \uncover<4->{void demo\_flat(\highlight{int a[][3]}) \{\\
    ~~a[1][2] *= 2;\\
    \}\\}
~\\
    int main() \{\\
    \uncover<2->{~~int f[][3] = \{ \{0, 1, 2\},\\
    ~~~~~~~~~~~~~~~~~\{3, 4, 5\} \};\\
    \uncover<3->{~~demo\_flat(f);\\}}
    ~~return 0;\\
    \}
}

=== Variante "Hybrid" ===

==== 2D-Array-Hybrid ====
{\ttfamily\Large
    \uncover<5->{void demo\_flat(\highlight{int a[][3]});\\
    void demo\_deep(\highlight{int *} const \highlight{*a});\\}
~\\
    int main() \{\\
    \uncover<2->{~~int f[][3] = \{ \{0, 1, 2\},\\
    ~~~~~~~~~~~~~~~~~\{3, 4, 5\} \};\\
    \uncover<3->{~~int * const d[] = \{f[0], f[1]\};\\
    \uncover<4->{~~demo\_flat(f);\\
    ~~demo\_deep(d);\\}}}
    ~~return 0;\\
    \}
}

== Deklaration von Strings ==

==== Deklaration von Strings ====
{\Large
    \uncover<3->{Variante "Mit Array"\\}
    \ind{}\texttt{char a[] = "Hallo";}\\
    \uncover<2->{\ind{}\texttt{sizeof(a) == sizeof(char)*(5 + 1)}\\}
    \uncover<4->{\ind{}Inhalt les- und schreibbar\\}
~\\
    \uncover<5->{Variante "Nur Pointer"\\}
    \uncover<6->{\ind{}\texttt{\only<9->{\highlight{const} }char *p = "Hallo";}\\}  % gcc -Wwrite-strings 
    \uncover<7->{\ind{}\texttt{sizeof(p) == sizeof(char *)}\\}
    \uncover<8->{\ind{}Inhalt \emph{nicht} schreibbar\\}
}


%==== Strings versus "Memory" ====
\comment{\Large
    \underline{str}ncpy(\underline{char} *dest, const \underline{char} *src, size\_t n);\\[1.5ex]
    \underline{mem}cpy(\underline{void} *dest, const \underline{void} *src, size\_t n);\\[0.5ex]
    \uncover<2->{ohne Null-Byte-Behandlung}
}


== NULL-Pointer ==

==== NULL-Pointer ====
{\ttfamily\Large
    \#include <stdlib.h>~~/* for NULL */\\
    ...\\
    char *foo = NULL;\\
    ...\\
    printf("foo = '\%s'$\backslash$n", foo);\uncover<2->{\textsf{~\highlight{ <-- BANG!}}}\\
}


== Weiterführende Themen ==

==== Weiterführende Themen ====
{\Large
* Character encodings, Unicode, wchar\_t
* Sicherer Umgang mit Strings
* Der Typ size\_t
* Void-Pointer
* Funktions-Pointer
}


== Zusammenfassung ==

==== Zusammenfassung ====
{\Large
* \texttt{sizeof(\emph{x})} liefert die Größe von \texttt{\emph{x}} in Byte
* \&-Operator liefert eine Adresse
* *-Operator dereferenziert
* Pointer sind typisiert
* Arrays sind auch Pointer auf ihr erstes Element
* Strings sind nulltermininiert
* const correctness bei Pointern ist wichtig
}


==== ====
<[center]
{\Huge
Danke!\\
~\\
Fragen?\\
\vfill
\vfill
}
{\LARGE http://blog.hartwork.org/}
[center]>
\vspace*{-4ex}